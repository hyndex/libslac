// ===== .git\logs\refs\remotes\origin\codex\update-include-logic-in-src\slac.cpp =====
0000000000000000000000000000000000000000 0f53d3f853438df24c751ef97f8a6fbd58b5ac31 Chinmoy Bhuyan <dikibhuyan@gmail.com> 1753378808 +0530	fetch: storing head


// ===== .git\logs\refs\remotes\origin\codex\update-preprocessor-directive-in-sha256.cpp =====
0000000000000000000000000000000000000000 f2f97e347d03c2605241b21004a4db6c6726b249 Chinmoy Bhuyan <dikibhuyan@gmail.com> 1753378808 +0530	fetch: storing head


// ===== .git\refs\remotes\origin\codex\update-include-logic-in-src\slac.cpp =====
0f53d3f853438df24c751ef97f8a6fbd58b5ac31


// ===== .git\refs\remotes\origin\codex\update-preprocessor-directive-in-sha256.cpp =====
f2f97e347d03c2605241b21004a4db6c6726b249


// ===== 3rd_party\fsm\fsm\_impl\common.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2023 - 2023 Pionix GmbH and Contributors to EVerest
#ifndef LIBFSM__IMPL_COMMON_HPP
#define LIBFSM__IMPL_COMMON_HPP

#include <type_traits>

namespace fsm::_impl {

template <template <typename, typename, typename> typename BaseStateType, typename DerivedStateType>
struct is_base_state_of {
    using BaseType = BaseStateType<typename DerivedStateType::EventType, typename DerivedStateType::ReturnType,
                                   typename DerivedStateType::AllocatorType>;
    static const bool value = std::is_base_of<BaseType, DerivedStateType>::value;
};

enum class FeedResultState {
    TRANSITION,
    UNHANDLED_EVENT,
    INTERNAL_ERROR,
    HAS_VALUE,
    NO_VALUE,
};

} // namespace fsm::_impl

#endif // LIBFSM__IMPL_COMMON_HPP


// ===== 3rd_party\fsm\fsm\_impl\state_allocator.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2023 - 2023 Pionix GmbH and Contributors to EVerest
#ifndef LIBFSM__IMPL_STATE_ALLOCATOR_HPP
#define LIBFSM__IMPL_STATE_ALLOCATOR_HPP

namespace fsm::_impl {

template <typename SwapAllocatorBufferType> class StateAllocator;

class DynamicStateAllocator {
public:
    enum class InternalState {
        READY_FOR_CREATION,
        FAILED_MULTIPLE_SIMPLE_CREATE,
        FAILED_MULTIPLE_COMPOUND_CREATE,
    };

    DynamicStateAllocator() = default;
    DynamicStateAllocator(const DynamicStateAllocator& other) = delete;
    DynamicStateAllocator(DynamicStateAllocator&& other) = delete;
    DynamicStateAllocator& operator=(const DynamicStateAllocator& other) = delete;
    DynamicStateAllocator& operator=(DynamicStateAllocator&& other) = delete;

    template <typename StateType, typename... Args> bool create_compound(Args&&... args) {
        if (!preflight_compound()) {
            return false;
        }

        compound_state = new StateType(std::forward<Args>(args)...);
        return true;
    }

    template <typename StateType, typename... Args> bool create_simple(Args&&... args) {
        if (!preflight_simple()) {
            return false;
        }

        simple_state = new StateType(std::forward<Args>(args)...);
        return true;
    }

    template <typename SimpleStateType> auto pull_simple_state() {
        auto retval = reinterpret_cast<SimpleStateType*>(simple_state);
        if (retval) {
            simple_state = nullptr;
        }

        return retval;
    }

    template <typename CompoundStateType> auto pull_compound_state() {
        auto retval = reinterpret_cast<CompoundStateType*>(compound_state);
        if (retval) {
            compound_state = nullptr;
        }

        return retval;
    }

    void make_ready_for_allocation() {
        state = InternalState::READY_FOR_CREATION;
    }

    InternalState get_internal_state() const {
        return state;
    }

    bool has_staged_states() {
        return (simple_state != nullptr) || (compound_state != nullptr);
    }

    template <typename SimpleStateType, typename CompoundStateType> void release_staged_states() {
        if (simple_state != nullptr) {
            reinterpret_cast<SimpleStateType*>(simple_state)->~SimpleStateType();
        }

        if (compound_state != nullptr) {
            reinterpret_cast<CompoundStateType*>(compound_state)->~CompoundStateType();
        }
    }

private:
    bool preflight_simple() {
        if (state != InternalState::READY_FOR_CREATION) {
            return false;
        }

        if (simple_state) {
            state = InternalState::FAILED_MULTIPLE_SIMPLE_CREATE;
            return false;
        }

        return true;
    }

    bool preflight_compound() {
        if (state != InternalState::READY_FOR_CREATION) {
            return false;
        }

        if (compound_state) {
            state = InternalState::FAILED_MULTIPLE_COMPOUND_CREATE;
            return false;
        }

        return true;
    }

    void* compound_state{nullptr};
    void* simple_state{nullptr};

    InternalState state{InternalState::READY_FOR_CREATION};
};

template <typename SwapBufferType> class StateAllocator {
public:
    enum class InternalState {
        READY_FOR_CREATION,
        FAILED_COMPOUND_OVERFLOW,
        FAILED_MULTIPLE_SIMPLE_CREATE,
        FAILED_MULTIPLE_COMPOUND_CREATE,
    };

    StateAllocator(SwapBufferType& buffer_) : buffer(buffer_){};
    StateAllocator(const StateAllocator& other) = delete;
    StateAllocator(StateAllocator&& other) = delete;
    StateAllocator& operator=(const StateAllocator& other) = delete;
    StateAllocator& operator=(StateAllocator&& other) = delete;

    template <typename StateType, typename... Args> bool create_compound(Args&&... args) {
        static_assert(sizeof(StateType) <= buffer.MAX_COMPOUND_STATE_SIZE,
                      "Buffer too small for the supplied compound state type");
        if (!preflight_compound()) {
            return false;
        }

        auto& next_compound = buffer.compound[current_nested_level];
        auto next_buffer = next_compound.a_is_next ? next_compound.a : next_compound.b;
        next_compound.a_is_next = !next_compound.a_is_next;

        compound_state = new (next_buffer) StateType(std::forward<Args>(args)...);

        return true;
    }

    template <typename StateType, typename... Args> bool create_simple(Args&&... args) {
        static_assert(sizeof(StateType) <= buffer.MAX_SIMPLE_STATE_SIZE,
                      "Buffer too small for the supplied simple state type");
        if (!preflight_simple()) {
            return false;
        }

        auto next_buffer = (buffer.simple.a_is_next) ? buffer.simple.a : buffer.simple.b;
        buffer.simple.a_is_next = !buffer.simple.a_is_next;

        simple_state = new (next_buffer) StateType(std::forward<Args>(args)...);
        return true;
    }

    template <typename SimpleStateType> auto pull_simple_state() {
        auto retval = reinterpret_cast<SimpleStateType*>(simple_state);
        if (retval) {
            simple_state = nullptr;
        }

        return retval;
    }

    template <typename CompoundStateType> auto pull_compound_state() {
        auto retval = reinterpret_cast<CompoundStateType*>(compound_state);
        if (retval) {
            compound_state = nullptr;
        }

        return retval;
    }

    void make_ready_for_nesting_level(size_t level) {
        state = InternalState::READY_FOR_CREATION;
        current_nested_level = level;
    }

    InternalState get_internal_state() const {
        return state;
    }

    bool has_staged_states() {
        return (simple_state != nullptr) || (compound_state != nullptr);
    }

    template <typename SimpleStateType, typename CompoundStateType> void release_staged_states() {
        if (simple_state != nullptr) {
            reinterpret_cast<SimpleStateType*>(simple_state)->~SimpleStateType();
        }

        if (compound_state != nullptr) {
            reinterpret_cast<CompoundStateType*>(compound_state)->~CompoundStateType();
        }
    }

private:
    bool preflight_simple() {
        if (state != InternalState::READY_FOR_CREATION) {
            return false;
        }

        if (simple_state) {
            state = InternalState::FAILED_MULTIPLE_SIMPLE_CREATE;
            return false;
        }

        return true;
    }

    bool preflight_compound() {
        if (state != InternalState::READY_FOR_CREATION) {
            return false;
        }

        if (current_nested_level == SwapBufferType::MAX_NESTING_LEVEL) {
            state = InternalState::FAILED_COMPOUND_OVERFLOW;
            return false;
        }

        if (compound_state) {
            state = InternalState::FAILED_MULTIPLE_COMPOUND_CREATE;
            return false;
        }

        return true;
    }
    SwapBufferType& buffer;

    void* compound_state{nullptr};
    void* simple_state{nullptr};

    InternalState state{InternalState::READY_FOR_CREATION};

    size_t current_nested_level{0};
};

} // namespace fsm::_impl

#endif // LIBFSM__IMPL_STATE_ALLOCATOR_HPP


// ===== 3rd_party\fsm\fsm\buffer.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2023 - 2023 Pionix GmbH and Contributors to EVerest
#ifndef LIBFSM_BUFFER_HPP
#define LIBFSM_BUFFER_HPP

#include <cstddef>
#include <cstdint>

namespace fsm::buffer {
template <size_t MaxSimpleStateSize, size_t MaxCompoundStateSize, size_t MaxNestingLevel> struct SwapBuffer {
    static const size_t MAX_SIMPLE_STATE_SIZE = MaxSimpleStateSize;
    static const size_t MAX_COMPOUND_STATE_SIZE = MaxCompoundStateSize;
    static const size_t MAX_NESTING_LEVEL = MaxNestingLevel;

    struct SimpleStateBuffer {
        alignas(std::max_align_t) uint8_t a[MaxSimpleStateSize];
        alignas(std::max_align_t) uint8_t b[MaxSimpleStateSize];
        bool a_is_next{true};
    };

    SimpleStateBuffer simple{};

    struct CompoundStateBuffer {
        alignas(std::max_align_t) uint8_t a[MaxCompoundStateSize];
        alignas(std::max_align_t) uint8_t b[MaxCompoundStateSize];
        bool a_is_next{true};
    };

    CompoundStateBuffer compound[MAX_NESTING_LEVEL]{};
};

} // namespace fsm::buffer

#endif // LIBFSM_BUFFER_HPP


// ===== 3rd_party\fsm\fsm\fsm.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2023 - 2023 Pionix GmbH and Contributors to EVerest
#ifndef LIBFSM_FSM_HPP
#define LIBFSM_FSM_HPP

#include <array>
#include <memory>
#include <vector>

#include "_impl/common.hpp"
#include "_impl/state_allocator.hpp"

#include "states.hpp"

namespace fsm {

// FIXME (aw): we should treat internal unhandled events as errors because this doesn't make sense by design!
enum class HandleEventResult {
    SUCCESS,
    UNHANDLED,
    INTERNAL_ERROR,
};

// TODO (aw): would be good to know, if references or pointers can be passed as well
template <typename ResultType> class FeedResult {
private:
    using InternalState = _impl::FeedResultState;

public:
    FeedResult(InternalState state_) : state(state_){};
    FeedResult(ResultType value_) : value(value_), state(InternalState::HAS_VALUE){};

    bool has_value() const {
        return (state == InternalState::HAS_VALUE);
    }

    bool internal_error() const {
        return (state == InternalState::INTERNAL_ERROR);
    }

    bool transition() const {
        return (state == InternalState::TRANSITION);
    }

    bool unhandled_event() const {
        return (state == InternalState::UNHANDLED_EVENT);
    }

    ResultType& operator*() {
        return value;
    }

    ResultType* operator->() {
        return &value;
    }

private:
    ResultType value;
    InternalState state;
};

template <typename EventType, typename ReturnType, typename AllocatorBufferType = void> class FSM;

template <typename EventType, typename ReturnType> class FSM<EventType, ReturnType, void> {
public:
    using StateAllocatorType = states::StateAllocator<>;
    using SimpleStateType = states::SimpleStateBase<EventType, ReturnType, StateAllocatorType>;
    using CompoundStateType = states::CompoundStateBase<EventType, ReturnType, StateAllocatorType>;

    FSM() = default;
    FSM(const FSM& other) = delete;
    FSM(FSM&& other) = delete;
    FSM& operator=(const FSM& other) = delete;
    FSM& operator=(FSM&& other) = delete;
    ~FSM() {
        state_allocator.release_staged_states<SimpleStateType, CompoundStateType>();
        reset();
    }

    auto allocator_state() const {
        return state_allocator.get_internal_state();
    }

    template <typename StateType, typename... Args> void reset(Args&&... args) {
        reset();

        state_allocator.make_ready_for_allocation();
        state_allocator.create_simple<StateType>(std::forward<Args>(args)...);
        current_state.reset(state_allocator.pull_simple_state<SimpleStateType>());
        current_state->enter();
    }

    HandleEventResult handle_event(EventType ev) {
        if (current_state == nullptr) {
            return HandleEventResult::INTERNAL_ERROR;
        }

        auto next_nesting_level_to_handle = compound_stack.size();
        auto state_allocator_wrapper = StateAllocatorType(state_allocator);

        state_allocator.make_ready_for_allocation();

        auto result = current_state->handle_event(state_allocator_wrapper, ev);

        while (result.is_pass_on() && next_nesting_level_to_handle != 0) {
            next_nesting_level_to_handle--;
            state_allocator.make_ready_for_allocation();
            result = compound_stack[next_nesting_level_to_handle]->handle_event(state_allocator_wrapper, ev);
        }

        if (result.is_pass_on()) {
            if (state_allocator.has_staged_states()) {
                state_allocator.release_staged_states<SimpleStateType, CompoundStateType>();
            }
            return HandleEventResult::UNHANDLED;
        } else if (result.is_handled_internally()) {
            if (state_allocator.has_staged_states()) {
                state_allocator.release_staged_states<SimpleStateType, CompoundStateType>();
            }
            return HandleEventResult::SUCCESS;
        } else if (result.is_allocation_error()) {
            state_allocator.release_staged_states<SimpleStateType, CompoundStateType>();
            return HandleEventResult::INTERNAL_ERROR;
        }

        const auto handled_at_nesting_level = next_nesting_level_to_handle;

        // fall-though: event has been handled, clear current state and all states up to the handled level

        // note: this will change current_nesting_level
        reset(handled_at_nesting_level, true);

        auto const compound_state = state_allocator.pull_compound_state<CompoundStateType>();

        if (compound_state != nullptr) {
            compound_stack.emplace_back(compound_state);
            compound_state->enter();
        }

        auto const next_state = state_allocator.pull_simple_state<SimpleStateType>();
        if (next_state != nullptr) {
            next_state->enter();
            current_state.reset(next_state);

            return HandleEventResult::SUCCESS;
        }

        // this should never happen - i.e. when we come here that would mean, someone managed to return NEW_STATE from
        // the handle_event callback but didn't set the next state
        return HandleEventResult::INTERNAL_ERROR;
    }

    FeedResult<ReturnType> feed() {
        using FeedResultState = _impl::FeedResultState;
        if (current_state == nullptr) {
            return FeedResultState::INTERNAL_ERROR;
        }

        const auto result = current_state->callback();

        if (result.is_event) {
            switch (handle_event(result.event)) {
            case HandleEventResult::SUCCESS:
                return FeedResultState::TRANSITION;
            case HandleEventResult::UNHANDLED:
                return FeedResultState::UNHANDLED_EVENT;
            default:
                // NOTE: everything else should be an internal error
                return FeedResultState::INTERNAL_ERROR;
            }
        } else if (result.is_value_set) {
            return result.value;
        } else {
            return FeedResultState::NO_VALUE;
        }
    }

private:
    void reset(size_t up_to_nested_level = 0, bool execute_leave = false) {
        // leave and destroy everything allocated
        if (current_state) {
            if (execute_leave) {
                current_state->leave();
            }
            current_state.reset();
        }

        while (compound_stack.size() > up_to_nested_level) {
            if (execute_leave) {
                compound_stack.back()->leave();
            }
            compound_stack.pop_back();
        }
    }

    std::unique_ptr<SimpleStateType> current_state{nullptr};
    std::vector<std::unique_ptr<CompoundStateType>> compound_stack{};

    _impl::DynamicStateAllocator state_allocator;
};

template <typename EventType, typename ReturnType, typename AllocatorBufferType> class FSM {
public:
    using StateAllocatorType = states::StateAllocator<AllocatorBufferType>;
    using SimpleStateType = states::SimpleStateBase<EventType, ReturnType, StateAllocatorType>;
    using CompoundStateType = states::CompoundStateBase<EventType, ReturnType, StateAllocatorType>;

    FSM(AllocatorBufferType& buffer) :
        state_allocator(buffer){

        };

    FSM(const FSM& other) = delete;
    FSM(FSM&& other) = delete;
    FSM& operator=(const FSM& other) = delete;
    FSM& operator=(FSM&& other) = delete;
    ~FSM() {
        state_allocator.template release_staged_states<SimpleStateType, CompoundStateType>();
        reset();
    }

    auto allocator_state() const {
        return state_allocator.get_internal_state();
    }

    template <typename StateType, typename... Args> void reset(Args&&... args) {
        reset();

        state_allocator.make_ready_for_nesting_level(0);
        state_allocator.template create_simple<StateType>(std::forward<Args>(args)...);
        current_state = state_allocator.template pull_simple_state<SimpleStateType>();
        current_state->enter();
    }

    HandleEventResult handle_event(EventType ev) {
        if (current_state == nullptr) {
            return HandleEventResult::INTERNAL_ERROR;
        }

        auto next_nesting_level_to_handle = current_nesting_level;
        auto state_allocator_wrapper = StateAllocatorType(state_allocator);

        state_allocator.make_ready_for_nesting_level(next_nesting_level_to_handle);

        auto result = current_state->handle_event(state_allocator_wrapper, ev);

        while (result.is_pass_on() && next_nesting_level_to_handle != 0) {
            next_nesting_level_to_handle--;
            state_allocator.make_ready_for_nesting_level(next_nesting_level_to_handle);
            result = compound_states[next_nesting_level_to_handle]->handle_event(state_allocator_wrapper, ev);
        }

        if (result.is_pass_on()) {
            if (state_allocator.has_staged_states()) {
                state_allocator.template release_staged_states<SimpleStateType, CompoundStateType>();
            }
            return HandleEventResult::UNHANDLED;
        } else if (result.is_handled_internally()) {
            if (state_allocator.has_staged_states()) {
                state_allocator.template release_staged_states<SimpleStateType, CompoundStateType>();
            }
            return HandleEventResult::SUCCESS;
        } else if (result.is_allocation_error()) {
            state_allocator.template release_staged_states<SimpleStateType, CompoundStateType>();
            return HandleEventResult::INTERNAL_ERROR;
        }

        const auto handled_at_nesting_level = next_nesting_level_to_handle;

        // fall-though: event has been handled, clear current state and all states up to the handled level

        // note: this will change current_nesting_level
        reset(handled_at_nesting_level, true);

        const auto compound_state = state_allocator.template pull_compound_state<CompoundStateType>();

        if (compound_state != nullptr) {
            // compound state has been set
            current_nesting_level = handled_at_nesting_level + 1;
            compound_states[handled_at_nesting_level] = compound_state;

            compound_state->enter();
        }

        const auto next_state = state_allocator.template pull_simple_state<SimpleStateType>();
        if (next_state != nullptr) {
            next_state->enter();
            current_state = next_state;

            return HandleEventResult::SUCCESS;
        }

        // this should never happen - i.e. when we come here that would mean, someone managed to return NEW_STATE from
        // the handle_event callback but didn't set the next state
        return HandleEventResult::INTERNAL_ERROR;
    }

    FeedResult<ReturnType> feed() {
        using FeedResultState = _impl::FeedResultState;
        if (current_state == nullptr) {
            return FeedResultState::INTERNAL_ERROR;
        }

        const auto result = current_state->callback();

        if (result.is_event) {
            switch (handle_event(result.event)) {
            case HandleEventResult::SUCCESS:
                return FeedResultState::TRANSITION;
            case HandleEventResult::UNHANDLED:
                return FeedResultState::UNHANDLED_EVENT;
            default:
                // NOTE: everything else should be an internal error
                return FeedResultState::INTERNAL_ERROR;
            }
        } else if (result.is_value_set) {
            return result.value;
        } else {
            return FeedResultState::NO_VALUE;
        }
    }

private:
    void reset(size_t up_to_nested_level = 0, bool execute_leave = false) {
        // leave and destroy everything allocated
        if (current_state) {
            if (execute_leave) {
                current_state->leave();
            }
            current_state->~SimpleStateBase();
            current_state = nullptr;
        }

        while (current_nesting_level > up_to_nested_level) {
            auto& compound_state = compound_states[current_nesting_level - 1];
            if (execute_leave) {
                compound_state->leave();
            }
            compound_state->~CompoundStateBase();
            compound_state = nullptr;
            current_nesting_level--;
        }
    }

    SimpleStateType* current_state{nullptr};
    std::array<CompoundStateType*, AllocatorBufferType::MAX_NESTING_LEVEL> compound_states{};
    size_t current_nesting_level{0};

    _impl::StateAllocator<AllocatorBufferType> state_allocator;
};

} // namespace fsm

#endif // LIBFSM_FSM_HPP


// ===== 3rd_party\fsm\fsm\states.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2023 - 2023 Pionix GmbH and Contributors to EVerest
#ifndef LIBFSM_STATES_HPP
#define LIBFSM_STATES_HPP

#include "_impl/state_allocator.hpp"

namespace fsm::states {

// forward declaration so it can be made friend of states::HandleEventResult
template <typename SwapBufferType> class StateAllocator;

class HandleEventResult {
private:
    enum class InternalState {
        NEW_STATE,
        HANDLED_INTERNALY,
        ALLOCATION_ERROR,
        PASS_ON,
    };

    constexpr HandleEventResult(InternalState state_) : state(state_){};

    InternalState state;

    template <typename SwapBufferType> friend class StateAllocator;

public:
    bool is_new_state() const {
        return InternalState::NEW_STATE == state;
    }

    bool is_allocation_error() const {
        return InternalState::ALLOCATION_ERROR == state;
    }

    bool is_pass_on() const {
        return InternalState::PASS_ON == state;
    }

    bool is_handled_internally() const {
        return InternalState::HANDLED_INTERNALY == state;
    }
};

template <typename EventType, typename ReturnType> struct CallbackResult {
    CallbackResult() = default;
    CallbackResult(ReturnType value_) : value(value_), is_value_set(true){};
    CallbackResult(EventType event_) : event(event_), is_event(true){};

    ReturnType value{0};
    EventType event;
    bool is_event{false};
    bool is_value_set{false};
};

template <typename EventType_, typename ReturnType_, typename StateAllocatorType> struct SimpleStateBase {
    using EventType = EventType_;
    using ReturnType = ReturnType_;
    using AllocatorType = StateAllocatorType;

    using CallbackReturnType = CallbackResult<EventType_, ReturnType>;
    using HandleEventReturnType = HandleEventResult;

    virtual void enter(){};
    virtual HandleEventReturnType handle_event(AllocatorType&, EventType) = 0;
    virtual CallbackReturnType callback() {
        return {};
    };
    virtual void leave(){};
    virtual ~SimpleStateBase() = default;
};

template <typename EventType_, typename ReturnType_, typename StateAllocatorType> struct CompoundStateBase {
    using EventType = EventType_;
    using ReturnType = ReturnType_;
    using AllocatorType = StateAllocatorType;

    using HandleEventReturnType = HandleEventResult;

    virtual void enter(){};
    virtual HandleEventReturnType handle_event(AllocatorType&, EventType) = 0;
    virtual void leave(){};
    virtual ~CompoundStateBase() = default;
};

template <typename StateType, typename ContextType> struct StateWithContext : public StateType {
    StateWithContext(ContextType& context) : ctx(context){};

protected:
    ContextType& ctx;
};

template <typename SwapAllocatorBufferType = void> class StateAllocator;

template <> class StateAllocator<void> {
public:
    StateAllocator(_impl::DynamicStateAllocator& allocator_) : allocator(allocator_){};

    template <typename StateType, typename... Args> void create_compound(Args&&... args) {
        static_assert(_impl::is_base_state_of<CompoundStateBase, StateType>::value,
                      "StateType needs to be derived from CompoundStateBase");
        allocator.create_compound<StateType>(std::forward<Args>(args)...);
    }

    template <typename StateType, typename... Args> HandleEventResult create_simple(Args&&... args) {
        static_assert(_impl::is_base_state_of<SimpleStateBase, StateType>::value,
                      "StateType needs to be derived from SimpleStateBase");

        using State = HandleEventResult::InternalState;
        const auto success = allocator.create_simple<StateType>(std::forward<Args>(args)...);
        return success ? State::NEW_STATE : State::ALLOCATION_ERROR;
    }

    auto allocator_state() const {
        return allocator.get_internal_state();
    }

    // NOTE (aw): this could also be a non-static function, which checks if any states have been set
    static constexpr HandleEventResult PASS_ON{HandleEventResult::InternalState::PASS_ON};
    static constexpr HandleEventResult HANDLED_INTERNALLY{HandleEventResult::InternalState::HANDLED_INTERNALY};

private:
    _impl::DynamicStateAllocator& allocator;
};

template <typename SwapBufferType> class StateAllocator {
public:
    StateAllocator(_impl::StateAllocator<SwapBufferType>& allocator_) : allocator(allocator_){};

    template <typename StateType, typename... Args> void create_compound(Args&&... args) {
        static_assert(_impl::is_base_state_of<CompoundStateBase, StateType>::value,
                      "StateType needs to be derived from CompoundStateBase");
        allocator.template create_compound<StateType>(std::forward<Args>(args)...);
    }

    template <typename StateType, typename... Args> HandleEventResult create_simple(Args&&... args) {
        static_assert(_impl::is_base_state_of<SimpleStateBase, StateType>::value,
                      "StateType needs to be derived from SimpleStateBase");

        using State = HandleEventResult::InternalState;
        const auto success = allocator.template create_simple<StateType>(std::forward<Args>(args)...);
        return success ? State::NEW_STATE : State::ALLOCATION_ERROR;
    }

    auto allocator_state() const {
        return allocator.get_internal_state();
    }

    // NOTE (aw): this could also be a non-static function, which checks if any states have been set
    static constexpr HandleEventResult PASS_ON{HandleEventResult::InternalState::PASS_ON};
    static constexpr HandleEventResult HANDLED_INTERNALLY{HandleEventResult::InternalState::HANDLED_INTERNALY};

private:
    _impl::StateAllocator<SwapBufferType>& allocator;
};

} // namespace fsm::states

#endif // LIBFSM_STATES_HPP


// ===== 3rd_party\hash_library\sha256.cpp =====
// SPDX-License-Identifier: Zlib

// //////////////////////////////////////////////////////////
// sha256.cpp
// Copyright (c) 2014,2015,2021 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

#include "port/port_common.hpp"
#include "sha256.h"
#include <cstring>

#ifdef _MSC_VER
#    include <intrin.h>
#endif

#include <slac/endian.hpp>

// #define SHA2_224_SEED_VECTOR

/// same as reset()
SHA256::SHA256() {
    reset();
}

/// restart
void SHA256::reset() {
    m_numBytes = 0;
    m_bufferSize = 0;

    // according to RFC 1321
    // "These words were obtained by taking the first thirty-two bits of the
    //  fractional parts of the square roots of the first eight prime numbers"
    m_hash[0] = 0x6a09e667;
    m_hash[1] = 0xbb67ae85;
    m_hash[2] = 0x3c6ef372;
    m_hash[3] = 0xa54ff53a;
    m_hash[4] = 0x510e527f;
    m_hash[5] = 0x9b05688c;
    m_hash[6] = 0x1f83d9ab;
    m_hash[7] = 0x5be0cd19;

#ifdef SHA2_224_SEED_VECTOR
    // if you want SHA2-224 instead then use these seeds
    // and throw away the last 32 bits of getHash
    m_hash[0] = 0xc1059ed8;
    m_hash[1] = 0x367cd507;
    m_hash[2] = 0x3070dd17;
    m_hash[3] = 0xf70e5939;
    m_hash[4] = 0xffc00b31;
    m_hash[5] = 0x68581511;
    m_hash[6] = 0x64f98fa7;
    m_hash[7] = 0xbefa4fa4;
#endif
}

namespace {
inline uint32_t rotate(uint32_t a, uint32_t c) {
    return (a >> c) | (a << (32 - c));
}

inline uint32_t swap(uint32_t x) {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap32(x);
#elif defined(_MSC_VER)
    return _byteswap_ulong(x);
#else
    return (x >> 24) | ((x >> 8) & 0x0000FF00) | ((x << 8) & 0x00FF0000) | (x << 24);
#endif
}

// mix functions for processBlock()
inline uint32_t f1(uint32_t e, uint32_t f, uint32_t g) {
    uint32_t term1 = rotate(e, 6) ^ rotate(e, 11) ^ rotate(e, 25);
    uint32_t term2 = (e & f) ^ (~e & g); //(g ^ (e & (f ^ g)))
    return term1 + term2;
}

inline uint32_t f2(uint32_t a, uint32_t b, uint32_t c) {
    uint32_t term1 = rotate(a, 2) ^ rotate(a, 13) ^ rotate(a, 22);
    uint32_t term2 = ((a | b) & c) | (a & b); //(a & (b ^ c)) ^ (b & c);
    return term1 + term2;
}
} // namespace

/// process 64 bytes
void SHA256::processBlock(const void* data) {
    // get last hash
    uint32_t a = m_hash[0];
    uint32_t b = m_hash[1];
    uint32_t c = m_hash[2];
    uint32_t d = m_hash[3];
    uint32_t e = m_hash[4];
    uint32_t f = m_hash[5];
    uint32_t g = m_hash[6];
    uint32_t h = m_hash[7];

    // data represented as 16x 32-bit words without violating strict aliasing
    uint32_t words[64];
    uint32_t inputWords[16];
    std::memcpy(inputWords, data, sizeof(inputWords));
    // convert to big endian
    int i;
    for (i = 0; i < 16; i++)
#if defined(__BYTE_ORDER) && (__BYTE_ORDER != 0) && (__BYTE_ORDER == __BIG_ENDIAN)
        words[i] = inputWords[i];
#else
        words[i] = swap(inputWords[i]);
#endif

    uint32_t x, y; // temporaries

    // first round
    x = h + f1(e, f, g) + 0x428a2f98 + words[0];
    y = f2(a, b, c);
    d += x;
    h = x + y;
    x = g + f1(d, e, f) + 0x71374491 + words[1];
    y = f2(h, a, b);
    c += x;
    g = x + y;
    x = f + f1(c, d, e) + 0xb5c0fbcf + words[2];
    y = f2(g, h, a);
    b += x;
    f = x + y;
    x = e + f1(b, c, d) + 0xe9b5dba5 + words[3];
    y = f2(f, g, h);
    a += x;
    e = x + y;
    x = d + f1(a, b, c) + 0x3956c25b + words[4];
    y = f2(e, f, g);
    h += x;
    d = x + y;
    x = c + f1(h, a, b) + 0x59f111f1 + words[5];
    y = f2(d, e, f);
    g += x;
    c = x + y;
    x = b + f1(g, h, a) + 0x923f82a4 + words[6];
    y = f2(c, d, e);
    f += x;
    b = x + y;
    x = a + f1(f, g, h) + 0xab1c5ed5 + words[7];
    y = f2(b, c, d);
    e += x;
    a = x + y;

    // secound round
    x = h + f1(e, f, g) + 0xd807aa98 + words[8];
    y = f2(a, b, c);
    d += x;
    h = x + y;
    x = g + f1(d, e, f) + 0x12835b01 + words[9];
    y = f2(h, a, b);
    c += x;
    g = x + y;
    x = f + f1(c, d, e) + 0x243185be + words[10];
    y = f2(g, h, a);
    b += x;
    f = x + y;
    x = e + f1(b, c, d) + 0x550c7dc3 + words[11];
    y = f2(f, g, h);
    a += x;
    e = x + y;
    x = d + f1(a, b, c) + 0x72be5d74 + words[12];
    y = f2(e, f, g);
    h += x;
    d = x + y;
    x = c + f1(h, a, b) + 0x80deb1fe + words[13];
    y = f2(d, e, f);
    g += x;
    c = x + y;
    x = b + f1(g, h, a) + 0x9bdc06a7 + words[14];
    y = f2(c, d, e);
    f += x;
    b = x + y;
    x = a + f1(f, g, h) + 0xc19bf174 + words[15];
    y = f2(b, c, d);
    e += x;
    a = x + y;

    // extend to 24 words
    for (; i < 24; i++)
        words[i] = words[i - 16] + (rotate(words[i - 15], 7) ^ rotate(words[i - 15], 18) ^ (words[i - 15] >> 3)) +
                   words[i - 7] + (rotate(words[i - 2], 17) ^ rotate(words[i - 2], 19) ^ (words[i - 2] >> 10));

    // third round
    x = h + f1(e, f, g) + 0xe49b69c1 + words[16];
    y = f2(a, b, c);
    d += x;
    h = x + y;
    x = g + f1(d, e, f) + 0xefbe4786 + words[17];
    y = f2(h, a, b);
    c += x;
    g = x + y;
    x = f + f1(c, d, e) + 0x0fc19dc6 + words[18];
    y = f2(g, h, a);
    b += x;
    f = x + y;
    x = e + f1(b, c, d) + 0x240ca1cc + words[19];
    y = f2(f, g, h);
    a += x;
    e = x + y;
    x = d + f1(a, b, c) + 0x2de92c6f + words[20];
    y = f2(e, f, g);
    h += x;
    d = x + y;
    x = c + f1(h, a, b) + 0x4a7484aa + words[21];
    y = f2(d, e, f);
    g += x;
    c = x + y;
    x = b + f1(g, h, a) + 0x5cb0a9dc + words[22];
    y = f2(c, d, e);
    f += x;
    b = x + y;
    x = a + f1(f, g, h) + 0x76f988da + words[23];
    y = f2(b, c, d);
    e += x;
    a = x + y;

    // extend to 32 words
    for (; i < 32; i++)
        words[i] = words[i - 16] + (rotate(words[i - 15], 7) ^ rotate(words[i - 15], 18) ^ (words[i - 15] >> 3)) +
                   words[i - 7] + (rotate(words[i - 2], 17) ^ rotate(words[i - 2], 19) ^ (words[i - 2] >> 10));

    // fourth round
    x = h + f1(e, f, g) + 0x983e5152 + words[24];
    y = f2(a, b, c);
    d += x;
    h = x + y;
    x = g + f1(d, e, f) + 0xa831c66d + words[25];
    y = f2(h, a, b);
    c += x;
    g = x + y;
    x = f + f1(c, d, e) + 0xb00327c8 + words[26];
    y = f2(g, h, a);
    b += x;
    f = x + y;
    x = e + f1(b, c, d) + 0xbf597fc7 + words[27];
    y = f2(f, g, h);
    a += x;
    e = x + y;
    x = d + f1(a, b, c) + 0xc6e00bf3 + words[28];
    y = f2(e, f, g);
    h += x;
    d = x + y;
    x = c + f1(h, a, b) + 0xd5a79147 + words[29];
    y = f2(d, e, f);
    g += x;
    c = x + y;
    x = b + f1(g, h, a) + 0x06ca6351 + words[30];
    y = f2(c, d, e);
    f += x;
    b = x + y;
    x = a + f1(f, g, h) + 0x14292967 + words[31];
    y = f2(b, c, d);
    e += x;
    a = x + y;

    // extend to 40 words
    for (; i < 40; i++)
        words[i] = words[i - 16] + (rotate(words[i - 15], 7) ^ rotate(words[i - 15], 18) ^ (words[i - 15] >> 3)) +
                   words[i - 7] + (rotate(words[i - 2], 17) ^ rotate(words[i - 2], 19) ^ (words[i - 2] >> 10));

    // fifth round
    x = h + f1(e, f, g) + 0x27b70a85 + words[32];
    y = f2(a, b, c);
    d += x;
    h = x + y;
    x = g + f1(d, e, f) + 0x2e1b2138 + words[33];
    y = f2(h, a, b);
    c += x;
    g = x + y;
    x = f + f1(c, d, e) + 0x4d2c6dfc + words[34];
    y = f2(g, h, a);
    b += x;
    f = x + y;
    x = e + f1(b, c, d) + 0x53380d13 + words[35];
    y = f2(f, g, h);
    a += x;
    e = x + y;
    x = d + f1(a, b, c) + 0x650a7354 + words[36];
    y = f2(e, f, g);
    h += x;
    d = x + y;
    x = c + f1(h, a, b) + 0x766a0abb + words[37];
    y = f2(d, e, f);
    g += x;
    c = x + y;
    x = b + f1(g, h, a) + 0x81c2c92e + words[38];
    y = f2(c, d, e);
    f += x;
    b = x + y;
    x = a + f1(f, g, h) + 0x92722c85 + words[39];
    y = f2(b, c, d);
    e += x;
    a = x + y;

    // extend to 48 words
    for (; i < 48; i++)
        words[i] = words[i - 16] + (rotate(words[i - 15], 7) ^ rotate(words[i - 15], 18) ^ (words[i - 15] >> 3)) +
                   words[i - 7] + (rotate(words[i - 2], 17) ^ rotate(words[i - 2], 19) ^ (words[i - 2] >> 10));

    // sixth round
    x = h + f1(e, f, g) + 0xa2bfe8a1 + words[40];
    y = f2(a, b, c);
    d += x;
    h = x + y;
    x = g + f1(d, e, f) + 0xa81a664b + words[41];
    y = f2(h, a, b);
    c += x;
    g = x + y;
    x = f + f1(c, d, e) + 0xc24b8b70 + words[42];
    y = f2(g, h, a);
    b += x;
    f = x + y;
    x = e + f1(b, c, d) + 0xc76c51a3 + words[43];
    y = f2(f, g, h);
    a += x;
    e = x + y;
    x = d + f1(a, b, c) + 0xd192e819 + words[44];
    y = f2(e, f, g);
    h += x;
    d = x + y;
    x = c + f1(h, a, b) + 0xd6990624 + words[45];
    y = f2(d, e, f);
    g += x;
    c = x + y;
    x = b + f1(g, h, a) + 0xf40e3585 + words[46];
    y = f2(c, d, e);
    f += x;
    b = x + y;
    x = a + f1(f, g, h) + 0x106aa070 + words[47];
    y = f2(b, c, d);
    e += x;
    a = x + y;

    // extend to 56 words
    for (; i < 56; i++)
        words[i] = words[i - 16] + (rotate(words[i - 15], 7) ^ rotate(words[i - 15], 18) ^ (words[i - 15] >> 3)) +
                   words[i - 7] + (rotate(words[i - 2], 17) ^ rotate(words[i - 2], 19) ^ (words[i - 2] >> 10));

    // seventh round
    x = h + f1(e, f, g) + 0x19a4c116 + words[48];
    y = f2(a, b, c);
    d += x;
    h = x + y;
    x = g + f1(d, e, f) + 0x1e376c08 + words[49];
    y = f2(h, a, b);
    c += x;
    g = x + y;
    x = f + f1(c, d, e) + 0x2748774c + words[50];
    y = f2(g, h, a);
    b += x;
    f = x + y;
    x = e + f1(b, c, d) + 0x34b0bcb5 + words[51];
    y = f2(f, g, h);
    a += x;
    e = x + y;
    x = d + f1(a, b, c) + 0x391c0cb3 + words[52];
    y = f2(e, f, g);
    h += x;
    d = x + y;
    x = c + f1(h, a, b) + 0x4ed8aa4a + words[53];
    y = f2(d, e, f);
    g += x;
    c = x + y;
    x = b + f1(g, h, a) + 0x5b9cca4f + words[54];
    y = f2(c, d, e);
    f += x;
    b = x + y;
    x = a + f1(f, g, h) + 0x682e6ff3 + words[55];
    y = f2(b, c, d);
    e += x;
    a = x + y;

    // extend to 64 words
    for (; i < 64; i++)
        words[i] = words[i - 16] + (rotate(words[i - 15], 7) ^ rotate(words[i - 15], 18) ^ (words[i - 15] >> 3)) +
                   words[i - 7] + (rotate(words[i - 2], 17) ^ rotate(words[i - 2], 19) ^ (words[i - 2] >> 10));

    // eigth round
    x = h + f1(e, f, g) + 0x748f82ee + words[56];
    y = f2(a, b, c);
    d += x;
    h = x + y;
    x = g + f1(d, e, f) + 0x78a5636f + words[57];
    y = f2(h, a, b);
    c += x;
    g = x + y;
    x = f + f1(c, d, e) + 0x84c87814 + words[58];
    y = f2(g, h, a);
    b += x;
    f = x + y;
    x = e + f1(b, c, d) + 0x8cc70208 + words[59];
    y = f2(f, g, h);
    a += x;
    e = x + y;
    x = d + f1(a, b, c) + 0x90befffa + words[60];
    y = f2(e, f, g);
    h += x;
    d = x + y;
    x = c + f1(h, a, b) + 0xa4506ceb + words[61];
    y = f2(d, e, f);
    g += x;
    c = x + y;
    x = b + f1(g, h, a) + 0xbef9a3f7 + words[62];
    y = f2(c, d, e);
    f += x;
    b = x + y;
    x = a + f1(f, g, h) + 0xc67178f2 + words[63];
    y = f2(b, c, d);
    e += x;
    a = x + y;

    // update hash
    m_hash[0] += a;
    m_hash[1] += b;
    m_hash[2] += c;
    m_hash[3] += d;
    m_hash[4] += e;
    m_hash[5] += f;
    m_hash[6] += g;
    m_hash[7] += h;
}

/// add arbitrary number of bytes
void SHA256::add(const void* data, size_t numBytes) {
    const uint8_t* current = (const uint8_t*)data;

    if (m_bufferSize > 0) {
        while (numBytes > 0 && m_bufferSize < BlockSize) {
            m_buffer[m_bufferSize++] = *current++;
            numBytes--;
        }
    }

    // full buffer
    if (m_bufferSize == BlockSize) {
        processBlock(m_buffer);
        m_numBytes += BlockSize;
        m_bufferSize = 0;
    }

    // no more data ?
    if (numBytes == 0)
        return;

    // process full blocks
    while (numBytes >= BlockSize) {
        processBlock(current);
        current += BlockSize;
        m_numBytes += BlockSize;
        numBytes -= BlockSize;
    }

    // keep remaining bytes in buffer
    while (numBytes > 0) {
        m_buffer[m_bufferSize++] = *current++;
        numBytes--;
    }
}

/// process final block, less than 64 bytes
void SHA256::processBuffer() {
    // the input bytes are considered as bits strings, where the first bit is the most significant bit of the byte

    // - append "1" bit to message
    // - append "0" bits until message length in bit mod 512 is 448
    // - append length as 64 bit integer

    // number of bits
    size_t paddedLength = m_bufferSize * 8;

    // plus one bit set to 1 (always appended)
    paddedLength++;

    // number of bits must be (numBits % 512) = 448
    size_t lower11Bits = paddedLength & 511;
    if (lower11Bits <= 448)
        paddedLength += 448 - lower11Bits;
    else
        paddedLength += 512 + 448 - lower11Bits;
    // convert from bits to bytes
    paddedLength /= 8;

    // only needed if additional data flows over into a second block
    unsigned char extra[BlockSize];

    // append a "1" bit, 128 => binary 10000000
    if (m_bufferSize < BlockSize)
        m_buffer[m_bufferSize] = 128;
    else
        extra[0] = 128;

    size_t i;
    for (i = m_bufferSize + 1; i < BlockSize; i++)
        m_buffer[i] = 0;
    for (; i < paddedLength; i++)
        extra[i - BlockSize] = 0;

    // add message length in bits as 64 bit number
    uint64_t msgBits = 8 * (m_numBytes + m_bufferSize);
    // find right position
    unsigned char* addLength;
    if (paddedLength < BlockSize)
        addLength = m_buffer + paddedLength;
    else
        addLength = extra + paddedLength - BlockSize;

    // must be big endian
    *addLength++ = (unsigned char)((msgBits >> 56) & 0xFF);
    *addLength++ = (unsigned char)((msgBits >> 48) & 0xFF);
    *addLength++ = (unsigned char)((msgBits >> 40) & 0xFF);
    *addLength++ = (unsigned char)((msgBits >> 32) & 0xFF);
    *addLength++ = (unsigned char)((msgBits >> 24) & 0xFF);
    *addLength++ = (unsigned char)((msgBits >> 16) & 0xFF);
    *addLength++ = (unsigned char)((msgBits >> 8) & 0xFF);
    *addLength = (unsigned char)(msgBits & 0xFF);

    // process blocks
    processBlock(m_buffer);
    // flowed over into a second block ?
    if (paddedLength > BlockSize)
        processBlock(extra);
}

/// return latest hash as 64 hex characters
std::string SHA256::getHash() {
    // compute hash (as raw bytes)
    unsigned char rawHash[HashBytes];
    getHash(rawHash);

    // convert to hex string
    std::string result;
    result.reserve(2 * HashBytes);
    for (int i = 0; i < HashBytes; i++) {
        static const char dec2hex[16 + 1] = "0123456789abcdef";
        result += dec2hex[(rawHash[i] >> 4) & 15];
        result += dec2hex[rawHash[i] & 15];
    }

    return result;
}

/// return latest hash as bytes
void SHA256::getHash(unsigned char buffer[SHA256::HashBytes]) {
    // save old hash if buffer is partially filled
    uint32_t oldHash[HashValues];
    for (int i = 0; i < HashValues; i++)
        oldHash[i] = m_hash[i];

    // process remaining bytes
    processBuffer();

    unsigned char* current = buffer;
    for (int i = 0; i < HashValues; i++) {
        *current++ = (m_hash[i] >> 24) & 0xFF;
        *current++ = (m_hash[i] >> 16) & 0xFF;
        *current++ = (m_hash[i] >> 8) & 0xFF;
        *current++ = m_hash[i] & 0xFF;

        // restore old hash
        m_hash[i] = oldHash[i];
    }
}

/// compute SHA256 of a memory block
std::string SHA256::operator()(const void* data, size_t numBytes) {
    reset();
    add(data, numBytes);
    return getHash();
}

/// compute SHA256 of a string, excluding final zero
std::string SHA256::operator()(const std::string& text) {
    reset();
    add(text.c_str(), text.size());
    return getHash();
}


// ===== 3rd_party\hash_library\sha256.h =====
// SPDX-License-Identifier: Zlib

// //////////////////////////////////////////////////////////
// sha256.h
// Copyright (c) 2014,2015 Stephan Brumme. All rights reserved.
// see http://create.stephan-brumme.com/disclaimer.html
//

#pragma once

//#include "hash.h"
#include <string>

// define fixed size integer types
#ifdef _MSC_VER
// Windows
typedef unsigned __int8  uint8_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int64 uint64_t;
#else
// GCC
#include <stdint.h>
#endif


/// compute SHA256 hash
/** Usage:
    SHA256 sha256;
    std::string myHash  = sha256("Hello World");     // std::string
    std::string myHash2 = sha256("How are you", 11); // arbitrary data, 11 bytes

    // or in a streaming fashion:

    SHA256 sha256;
    while (more data available)
      sha256.add(pointer to fresh data, number of new bytes);
    std::string myHash3 = sha256.getHash();
  */
class SHA256 //: public Hash
{
public:
  /// split into 64 byte blocks (=> 512 bits), hash is 32 bytes long
  enum { BlockSize = 512 / 8, HashBytes = 32 };

  /// same as reset()
  SHA256();

  /// compute SHA256 of a memory block
  std::string operator()(const void* data, size_t numBytes);
  /// compute SHA256 of a string, excluding final zero
  std::string operator()(const std::string& text);

  /// add arbitrary number of bytes
  void add(const void* data, size_t numBytes);

  /// return latest hash as 64 hex characters
  std::string getHash();
  /// return latest hash as bytes
  void        getHash(unsigned char buffer[HashBytes]);

  /// restart
  void reset();

private:
  /// process 64 bytes
  void processBlock(const void* data);
  /// process everything left in the internal buffer
  void processBuffer();

  /// size of processed data in bytes
  uint64_t m_numBytes;
  /// valid bytes in m_buffer
  size_t   m_bufferSize;
  /// bytes not processed yet
  uint8_t  m_buffer[BlockSize];

  enum { HashValues = HashBytes / 4 };
  /// hash, stored as integers
  uint32_t m_hash[HashValues];
};


// ===== examples\platformio_complete\src\main.cpp =====
#include <Arduino.h>
#include <slac/channel.hpp>
#include <slac/slac.hpp>
#include <port/esp32s3/qca7000_link.hpp>

// Default MAC address for the modem. Adjust as required.
static const uint8_t MY_MAC[ETH_ALEN] = {0x02, 0x00, 0x00, 0x00, 0x00, 0x01};

// Global pointer used by the polling loop
static slac::Channel* g_channel = nullptr;

void setup() {
    Serial.begin(115200);

    // Initialise the SPI bus with custom chip select pin.
    // PLC_SPI_CS_PIN and PLC_SPI_RST_PIN can be overridden via
    // build flags in platformio.ini to match your wiring.
    // Use default SPI pins for the selected board. Chip select can be
    // overridden via PLC_SPI_CS_PIN build flag.
    SPI.begin();
    qca7000_config cfg{&SPI, PLC_SPI_CS_PIN, PLC_SPI_RST_PIN, MY_MAC};

    static slac::port::Qca7000Link link(cfg);
    static slac::Channel channel(&link);
    g_channel = &channel;
    if (!channel.open()) {
        Serial.println("Failed to open SLAC channel, aborting");
        g_channel = nullptr;
        while (true)
            delay(1000);
    }

    // send a minimal CM_SLAC_PARM.REQ as an example
    slac::messages::HomeplugMessage msg;
    slac::messages::cm_slac_parm_req req{};
    req.application_type = 0;
    req.security_type = 0;
    memset(req.run_id, 0x00, sizeof(req.run_id));

    if (!msg.setup_payload(&req, sizeof(req),
                           slac::defs::MMTYPE_CM_SLAC_PARAM | slac::defs::MMTYPE_MODE_REQ,
                           slac::defs::MMV::AV_1_0)) {
        Serial.println("setup_payload failed: payload too large");
    } else {
        uint8_t dst_mac[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
        msg.setup_ethernet_header(dst_mac);
        if (!channel.write(msg, 1000)) {
            Serial.println("Failed to transmit SLAC parameter request");
        }
    }
}

void loop() {
    // Poll the modem even when the IRQ line is not connected.
    qca7000Process();

    slac::messages::HomeplugMessage msg;
    if (g_channel && g_channel->poll(msg)) {
        // Handle incoming SLAC messages here
    }
    delay(1);
}


// ===== examples\platformio_complete\test\test_basic.cpp =====
#include <cassert>
#include <slac/channel.hpp>
#include <slac/transport.hpp>

class DummyLink : public slac::transport::Link {
public:
    bool open() override {
        return true;
    }
    bool write(const uint8_t*, size_t, uint32_t) override {
        return true;
    }
    slac::transport::LinkError read(uint8_t*, size_t, size_t* out_len, uint32_t) override {
        if (out_len)
            *out_len = 0;
        return slac::transport::LinkError::Ok;
    }
    const uint8_t* mac() const override {
        static const uint8_t mac[6] = {0};
        return mac;
    }
};

int main() {
    DummyLink link;
    slac::Channel channel(&link);
    assert(channel.open());
    return 0;
}


// ===== include\slac\channel.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2024 Joulepoint Private Limited (Author Chinmoy Bhuyan)
#ifndef SLAC_CHANNEL_HPP
#define SLAC_CHANNEL_HPP

#include "port/port_common.hpp"

#include <slac/transport.hpp>
#include <string>

// SPDX-License-Identifier: Apache-2.0
// Copyright 2020 - 2021 Pionix GmbH and Contributors to EVerest
#include <slac/slac.hpp>

namespace slac {

/**
 * \brief Convenience wrapper around a transport::Link.
 *
 * Channel does not manage the lifetime of the underlying Link; the caller must
 * create and maintain the link instance.  The current implementation operates
 * solely on untagged Ethernet frames and assumes that at most one SLAC session
 * is active.  Applications requiring VLAN encapsulation or multiplexing of
 * multiple sessions need to handle those aspects outside of this class.
 *
 * \note Thread Safety: Channel instances are \b not thread-safe.  Concurrent
 * access must be externally synchronized.
 */

class Channel {
public:
    explicit Channel(transport::Link* link);
    ~Channel();

    bool open();
    transport::LinkError read(slac::messages::HomeplugMessage& msg, int timeout);
    bool poll(slac::messages::HomeplugMessage& msg);
    bool write(slac::messages::HomeplugMessage& msg, int timeout);

    const std::string& get_error() const {
        return error;
    }

    bool got_timeout() const {
        return did_timeout;
    }

    const uint8_t* get_mac_addr();

private:
    transport::Link* link;
    uint8_t orig_if_mac[ETH_ALEN]{};

    std::string error;
    bool did_timeout{false};
};

} // namespace slac

#endif // SLAC_CHANNEL_HPP


// ===== include\slac\endian.hpp =====
#ifndef SLAC_ENDIAN_HPP
#define SLAC_ENDIAN_HPP

#include <cstdint>

#ifdef htole16
#undef htole16
#undef le16toh
#endif
#ifdef htole32
#undef htole32
#undef le32toh
#endif
#ifdef htole64
#undef htole64
#undef le64toh
#endif

#ifndef __LITTLE_ENDIAN
#define __LITTLE_ENDIAN 1234
#endif

#ifndef __BIG_ENDIAN
#define __BIG_ENDIAN 4321
#endif

#if defined(_WIN32)
#ifndef __BYTE_ORDER
#define __BYTE_ORDER __LITTLE_ENDIAN
#endif
#elif defined(__BYTE_ORDER__) && !defined(__BYTE_ORDER)
#define __BYTE_ORDER __BYTE_ORDER__
#elif defined(__BYTE_ORDER)
/* already defined */
#elif defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) || defined(__MIPSEL__)
#define __BYTE_ORDER __LITTLE_ENDIAN
#else
#define __BYTE_ORDER __BIG_ENDIAN
#endif

namespace slac {

static inline constexpr uint16_t bswap16(uint16_t v) {
    return __builtin_bswap16(v);
}
static inline constexpr uint32_t bswap32(uint32_t v) {
    return __builtin_bswap32(v);
}
static inline constexpr uint64_t bswap64(uint64_t v) {
    return __builtin_bswap64(v);
}


#if !defined(ESP_PLATFORM) && !defined(htole16)
inline constexpr uint16_t htole16(uint16_t v) {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    return v;
#else
    return bswap16(v);
#endif
}
inline constexpr uint16_t le16toh(uint16_t v) { return htole16(v); }
#endif


#if !defined(ESP_PLATFORM) && !defined(htole32)
inline constexpr uint32_t htole32(uint32_t v) {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    return v;
#else
    return bswap32(v);
#endif
}
inline constexpr uint32_t le32toh(uint32_t v) { return htole32(v); }
#endif

#if !defined(ESP_PLATFORM) && !defined(htole64)
inline constexpr uint64_t htole64(uint64_t v) {
#if __BYTE_ORDER == __LITTLE_ENDIAN
    return v;
#else
    return bswap64(v);
#endif
}
inline constexpr uint64_t le64toh(uint64_t v) { return htole64(v); }
#endif

} // namespace slac

#endif // SLAC_ENDIAN_HPP


// ===== include\slac\fsm.hpp =====
#ifndef SLAC_FSM_HPP
#define SLAC_FSM_HPP

#include <fsm/buffer.hpp>
#include <fsm/fsm.hpp>
#include <fsm/states.hpp>

namespace slac {

// Re-export libfsm into the slac namespace for convenience
namespace fsm = ::fsm;

enum class SlacEvent {
    GotParmCnf,
    SoundIntervalElapsed,
    GotAttenCharInd,
    GotSetKeyReq,
    GotMatchReq,
    Timeout,
    Error
};

} // namespace slac

#endif // SLAC_FSM_HPP


// ===== include\slac\iso15118_consts.hpp =====
#ifndef SLAC_ISO15118_CONSTS_HPP
#define SLAC_ISO15118_CONSTS_HPP

namespace slac {
namespace defs {

const int C_EV_START_ATTEN_CHAR_INDS = 3;
const int C_EV_MATCH_RETRY = 2;
const int C_EV_MATCH_MNBC = 10;
const int TP_EV_BATCH_MSG_INTERVAL_MS = 40; // 20ms - 50ms, interval between start_atten_char and mnbc_sound msgs
const int TT_EV_ATTEN_RESULTS_MS = 1200;    // max. 1200ms
const int TT_EVSE_MATCH_MNBC_MS = 600;
const int TT_MATCH_SEQUENCE_MS = 400;
const int TT_MATCH_RESPONSE_MS = 200;
const int TT_EVSE_MATCH_SESSION_MS = 10000;
const int TT_EVSE_SLAC_INIT_MS = 40000; // (20s - 50s)
const int TT_MATCH_JOIN_MS = 12000;     // max. 12s
const int T_STEP_EF_MS = 4000;          // min. 4s

} // namespace defs
} // namespace slac

#endif // SLAC_ISO15118_CONSTS_HPP


// ===== include\slac\slac.hpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2024 Joulepoint Private Limited (Author Chinmoy Bhuyan)
#ifndef SLAC_SLAC_HPP
#define SLAC_SLAC_HPP

#include "port/port_common.hpp"

#include <cstddef>
#include <cstdint>
#include <type_traits>
#include <utility>

#include "port/esp32s3/ethernet_defs.hpp"

namespace slac {

namespace defs {

const uint16_t ETH_P_HOMEPLUG_GREENPHY = 0x88E1;

enum class MMV : uint8_t {
    AV_1_0 = 0x0,
    AV_1_1 = 0x1,
    AV_2_0 = 0x2,
};

constexpr std::size_t MME_MIN_LENGTH = 60;

constexpr std::size_t STATION_ID_LEN = 17;
constexpr std::size_t NID_LEN = 7;
constexpr std::size_t NID_MOST_SIGNIFANT_BYTE_SHIFT = 4;
const uint8_t NID_SECURITY_LEVEL_SIMPLE_CONNECT = 0b00;
constexpr std::size_t NID_SECURITY_LEVEL_OFFSET = 4;

const uint8_t DAKS_HASH[] = {0x08, 0x85, 0x6d, 0xaf, 0x7c, 0xf5, 0x81, 0x85};
const uint8_t NMK_HASH[] = {0x08, 0x85, 0x6d, 0xaf, 0x7c, 0xf5, 0x81, 0x86};

constexpr std::size_t NMK_LEN = 16;

constexpr std::size_t AAG_LIST_LEN = 58;
constexpr std::size_t RUN_ID_LEN = 16;

const uint16_t MMTYPE_CM_SET_KEY = 0x6008;
const uint16_t MMTYPE_CM_SLAC_PARAM = 0x6064;
const uint16_t MMTYPE_CM_START_ATTEN_CHAR = 0x6068;
const uint16_t MMTYPE_CM_ATTEN_CHAR = 0x606C;
const uint16_t MMTYPE_CM_MNBC_SOUND = 0x6074;
const uint16_t MMTYPE_CM_VALIDATE = 0x6078;
const uint16_t MMTYPE_CM_SLAC_MATCH = 0x607C;
const uint16_t MMTYPE_CM_ATTEN_PROFILE = 0x6084;

// Qualcomm Vendor MMEs
namespace qualcomm {
const uint16_t MMTYPE_CM_RESET_DEVICE = 0xA01C;
const uint16_t MMTYPE_LINK_STATUS = 0xA0B8;
const uint16_t MMTYPE_OP_ATTR = 0xA068;
const uint16_t MMTYPE_NW_INFO = 0xA038;
const uint16_t MMTYPE_GET_SW = 0xA000;
} // namespace qualcomm

// Lumissil Vendor MMEs
namespace lumissil {
const uint16_t MMTYPE_NSCM_RESET_DEVICE = 0xAC70;
const uint16_t MMTYPE_NSCM_GET_VERSION = 0xAC6C;
const uint16_t MMTYPE_NSCM_GET_D_LINK_STATUS = 0xAC9C;
} // namespace lumissil

// Standard mmtypes
const uint16_t MMTYPE_MODE_REQ = 0x0000;
const uint16_t MMTYPE_MODE_CNF = 0x0001;
const uint16_t MMTYPE_MODE_IND = 0x0002;
const uint16_t MMTYPE_MODE_RSP = 0x0003;
const uint16_t MMTYPE_MODE_MASK = 0x0003;

const uint16_t MMTYPE_CATEGORY_STA_CCO = 0x0000;
const uint16_t MMTYPE_CATEGORY_PROXY = 0x2000;
const uint16_t MMTYPE_CATEGORY_CCO_CCO = 0x4000;
const uint16_t MMTYPE_CATEGORY_STA_STA = 0x6000;
const uint16_t MMTYPE_CATEGORY_MANUFACTOR_SPECIFIC = 0x8000;
const uint16_t MMTYPE_CATEGORY_VENDOR_SPECIFIC = 0xA000;
const uint16_t MMTYPE_CATEGORY_MASK = 0xE000;

const uint8_t COMMON_APPLICATION_TYPE = 0x00;
const uint8_t COMMON_SECURITY_TYPE = 0x00;

const uint8_t CM_VALIDATE_REQ_SIGNAL_TYPE = 0x00;
const uint8_t CM_VALIDATE_REQ_RESULT_READY = 0x01;
const uint8_t CM_VALIDATE_REQ_RESULT_FAILURE = 0x03;

const uint16_t CM_SLAC_MATCH_REQ_MVF_LENGTH = 0x3e;

const uint16_t CM_SLAC_MATCH_CNF_MVF_LENGTH = 0x56;

const uint8_t CM_SLAC_PARM_CNF_RESP_TYPE = 0x01; // = other GP station
const uint8_t CM_SLAC_PARM_CNF_NUM_SOUNDS = 10;  // typical value
const uint8_t CM_SLAC_PARM_CNF_TIMEOUT = 0x06;   // 600ms

const uint8_t CM_SET_KEY_REQ_KEY_TYPE_NMK = 0x01; // NMK (AES-128), Network Management Key
const uint8_t CM_SET_KEY_REQ_PID_HLE = 0x04;
const uint16_t CM_SET_KEY_REQ_PRN_UNUSED = 0x0000;
const uint8_t CM_SET_KEY_REQ_PMN_UNUSED = 0x00;
const uint8_t CM_SET_KEY_REQ_CCO_CAP_NONE = 0x00; // Level-0 CCo Capable, neither QoS nor TDMA
const uint8_t CM_SET_KEY_REQ_PEKS_NMK_KNOWN_TO_STA = 0x01;

const uint8_t CM_SET_KEY_CNF_RESULT_SUCCESS = 0x0;

const uint8_t CM_ATTEN_CHAR_RSP_RESULT = 0x00;

const uint8_t BROADCAST_MAC_ADDRESS[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

} // namespace defs

namespace utils {
void generate_nmk_hs(uint8_t nmk_hs[slac::defs::NMK_LEN], const char* plain_password, int password_len);
void generate_nid_from_nmk(uint8_t nid[slac::defs::NID_LEN], const uint8_t nmk[slac::defs::NMK_LEN]);
} // namespace utils

namespace messages {

typedef struct {
    struct ether_header ethernet_header;
    struct {
        uint8_t mmv;     // management message version
        uint16_t mmtype; // management message type

    } __attribute__((packed)) homeplug_header;

    // the rest of this message is potentially payload data
    uint8_t payload[ETH_FRAME_LEN - ETH_HLEN - sizeof(homeplug_header)];
} __attribute__((packed)) homeplug_message;

typedef struct {
    uint8_t fmni; // fragmentation management number information
    uint8_t fmsn; // fragmentation message sequence number
} __attribute__((packed)) homeplug_fragmentation_part;

class HomeplugMessage {
public:
    homeplug_message* get_raw_message_ptr() {
        return &raw_msg;
    };

    int get_raw_msg_len() const {
        return raw_msg_len;
    }

    void set_raw_msg_len(int len);

    /**
     * \brief Setup the SLAC payload of this HomePlug message
     *
     * Copies \p len bytes from \p payload into the internal buffer and sets
     * the appropriate HomePlug header fields.  The function returns false if
     * the payload would exceed the maximum size allowed for the chosen MMV
     * version.  On success the raw message length is adjusted and the message
     * becomes valid.
     */
    bool setup_payload(void const* payload, int len, uint16_t mmtype, const defs::MMV mmv);
    void setup_ethernet_header(const uint8_t dst_mac_addr[ETH_ALEN], const uint8_t src_mac_addr[ETH_ALEN] = nullptr);

    uint16_t get_mmtype() const;
    uint8_t* get_src_mac();

    template <typename T> const T& get_payload() {
        if (raw_msg.homeplug_header.mmv == static_cast<std::underlying_type_t<defs::MMV>>(defs::MMV::AV_1_0)) {
            return *reinterpret_cast<T*>(raw_msg.payload);
        }

        // if not av 1.0 message, we need to shift by the fragmentation part
        return *reinterpret_cast<T*>(raw_msg.payload + sizeof(homeplug_fragmentation_part));
    }

    bool is_valid() const;
    bool keep_source_mac() const {
        return keep_src_mac;
    }

private:
    homeplug_message raw_msg;

    int raw_msg_len{-1};
    bool keep_src_mac{false};
};

constexpr std::size_t M_SOUND_TARGET_LEN = 6;
constexpr std::size_t SENDER_ID_LEN = defs::STATION_ID_LEN;
constexpr std::size_t SOURCE_ID_LEN = defs::STATION_ID_LEN;
constexpr std::size_t RESP_ID_LEN = defs::STATION_ID_LEN;
constexpr std::size_t PEV_ID_LEN = defs::STATION_ID_LEN;
constexpr std::size_t EVSE_ID_LEN = defs::STATION_ID_LEN;

typedef struct {
    uint8_t application_type;         // fixed to 0x00, indicating 'pev-evse matching'
    uint8_t security_type;            // fixed to 0x00, indicating 'no security'
    uint8_t run_id[defs::RUN_ID_LEN]; // indentifier for a matching run
    // cipher fields are missing, because we restrict to security_type = 0x00
} __attribute__((packed)) cm_slac_parm_req;

typedef struct {
    uint8_t m_sound_target[M_SOUND_TARGET_LEN]; // fixed to 0xFFFFFFFFFFFF
    uint8_t num_sounds;                         // number of expected m-sounds
    uint8_t timeout;                            // corresponds to TT_EVSE_match_MNBC, in units of 100ms
    uint8_t resp_type;                          // fixed to 0x01, indicating 'other gp station'
    uint8_t forwarding_sta[ETH_ALEN];           // ev host mac address
    uint8_t application_type;                   // fixed to 0x00, indicating 'pev-evse matching'
    uint8_t security_type;                      // fixed to 0x00, indicating 'no security'
    uint8_t run_id[defs::RUN_ID_LEN];           // matching run identifier, corresponding to the request
    // cipher field is missing, because we restrict to security_type = 0x00
} __attribute__((packed)) cm_slac_parm_cnf;

typedef struct {
    uint8_t application_type;         // fixed to 0x00, indicating 'pev-evse matching'
    uint8_t security_type;            // fixed to 0x00, indicating 'no security'
    uint8_t num_sounds;               // number of expected m-sounds
    uint8_t timeout;                  // corresponds to TT_EVSE_match_MNBC
    uint8_t resp_type;                // fixed to 0x01, indicating 'other gp station'
    uint8_t forwarding_sta[ETH_ALEN]; // ev host mac address
    uint8_t run_id[defs::RUN_ID_LEN]; // indentifier for a matching run
} __attribute__((packed)) cm_start_atten_char_ind;

typedef struct {
    uint8_t application_type;         // fixed to 0x00, indicating 'pev-evse matching'
    uint8_t security_type;            // fixed to 0x00, indicating 'no security'
    uint8_t source_address[ETH_ALEN]; // mac address of EV host, which initiates matching
    uint8_t run_id[defs::RUN_ID_LEN]; // indentifier for a matching run
    uint8_t source_id[SOURCE_ID_LEN]; // unique id of the station, that sent the m-sounds
    uint8_t resp_id[RESP_ID_LEN];     // unique id of the station, that is sending this message
    uint8_t num_sounds;               // number of sounds used for attenuation profile
    struct {
        uint8_t num_groups;              // number of OFDM carrier groups
        uint8_t aag[defs::AAG_LIST_LEN]; // AAG_1 .. AAG_N
    } __attribute__((packed)) attenuation_profile;
} __attribute__((packed)) cm_atten_char_ind;

typedef struct {
    uint8_t application_type;         // fixed to 0x00, indicating 'pev-evse matching'
    uint8_t security_type;            // fixed to 0x00, indicating 'no security'
    uint8_t source_address[ETH_ALEN]; // mac address of EV host, which initiates matching
    uint8_t run_id[defs::RUN_ID_LEN]; // indentifier for a matching run
    uint8_t source_id[SOURCE_ID_LEN]; // unique id of the station, that sent the m-sounds
    uint8_t resp_id[RESP_ID_LEN];     // unique id of the station, that is sending this message
    uint8_t result;                   // fixed to 0x00, indicates successful SLAC process
} __attribute__((packed)) cm_atten_char_rsp;

typedef struct {
    uint8_t application_type;         // fixed to 0x00, indicating 'pev-evse matching'
    uint8_t security_type;            // fixed to 0x00, indicating 'no security'
    uint8_t sender_id[SENDER_ID_LEN]; // sender id, if application_type = 0x00, it should be the pev's vin code
    uint8_t remaining_sound_count;    // count of remaining sound messages
    uint8_t run_id[defs::RUN_ID_LEN]; // identifier for a matching run
    uint8_t random[16];               // random value
} __attribute__((packed)) cm_mnbc_sound_ind;

// note: this message doesn't seem to part of hpgp, it is defined in ISO15118-3
typedef struct {
    uint8_t pev_mac[ETH_ALEN]; // mac address of the EV host
    uint8_t num_groups;        // number of OFDM carrier groups
    uint8_t _reserved;
    uint8_t aag[defs::AAG_LIST_LEN]; // list of average attenuation for each group
} __attribute__((packed)) cm_atten_profile_ind;

typedef struct {
    uint8_t application_type;         // fixed to 0x00, indicating 'pev-evse matching'
    uint8_t security_type;            // fixed to 0x00, indicating 'no security'
    uint16_t mvf_length;              // fixed to 0x3e = 62 bytes following
    uint8_t pev_id[PEV_ID_LEN];       // vin code of PEV
    uint8_t pev_mac[ETH_ALEN];        // mac address of the EV host
    uint8_t evse_id[EVSE_ID_LEN];     // EVSE id
    uint8_t evse_mac[ETH_ALEN];       // mac address of the EVSE
    uint8_t run_id[defs::RUN_ID_LEN]; // identifier for a matching run
} __attribute__((packed)) cm_slac_match_req;

typedef struct {
    uint8_t application_type;         // fixed to 0x00, indicating 'pev-evse matching'
    uint8_t security_type;            // fixed to 0x00, indicating 'no security'
    uint16_t mvf_length;              // fixed to 0x56 = 86 bytes following
    uint8_t pev_id[PEV_ID_LEN];       // vin code of PEV
    uint8_t pev_mac[ETH_ALEN];        // mac address of the EV host
    uint8_t evse_id[EVSE_ID_LEN];     // EVSE id
    uint8_t evse_mac[ETH_ALEN];       // mac address of the EVSE
    uint8_t run_id[defs::RUN_ID_LEN]; // identifier for a matching run
    uint8_t nid[defs::NID_LEN];       // network id derived from the nmk
    uint8_t _reserved2;               // note: this is to pad the nid, which is defined to be 8 bytes for this message
    uint8_t nmk[defs::NMK_LEN];       // private nmk of the EVSE
} __attribute__((packed)) cm_slac_match_cnf;

typedef struct {
    uint8_t signal_type; // fixed to 0x00: PEV S2 toggles on control pilot line
    uint8_t timer;       // in the first request response exchange: should be set to 0x00
                         // in the second request response exchange: 0x00 = 100ms, 0x01 = 200ms TT_EVSE_vald_toggle
    uint8_t result;      // in the first request response exchange: should be set to 0x01 = ready
                         // in the second request response exchange: should be set to 0x01 = ready
} __attribute__((packed)) cm_validate_req;

typedef struct {
    uint8_t signal_type; // fixed to 0x00: PEV S2 toggles on control pilot line
    uint8_t toggle_num;  // in the first request response exchange: should be set to 0x00
                         // in the second request response exchange: number of detected BC
                         // edges during TT_EVSE_vald_toggle
    uint8_t result;      // 0x00 = not ready, 0x01 = ready, 0x02 = success, 0x03 = failure, 0x04 = not required
} __attribute__((packed)) cm_validate_cnf;

typedef struct {
    uint8_t key_type;               // fixed to 0x01, indicating NMK
    uint32_t my_nonce;              // fixed to 0x00000000: encrypted payload not used
    uint32_t your_nonce;            // fixed to 0x00000000: encrypted payload not used
    uint8_t pid;                    // fixed to 0x04: HLE protocol
    uint16_t prn;                   // fixed to 0x0000: encrypted payload not used
    uint8_t pmn;                    // fixed to 0x00: encrypted payload not used
    uint8_t cco_capability;         // CCo capability according to the station role
    uint8_t nid[defs::NID_LEN];     // 54 LSBs = NID, 2 MSBs = 0b00
    uint8_t new_eks;                // fixed to 0x01: NMK
    uint8_t new_key[defs::NMK_LEN]; // new NMK
} __attribute__((packed)) cm_set_key_req;

typedef struct {
    uint8_t result; // 0x00 = success, 0x01 = failure, 0x02 - 0xFF = reserved
    uint32_t my_nonce;
    uint32_t your_nonce;
    uint8_t pid;
    uint16_t prn;
    uint8_t pmn;
    uint8_t cco_capability;
} __attribute__((packed)) cm_set_key_cnf;

namespace qualcomm {

typedef struct {
    uint8_t vendor_mme[3] = {0x00, 0xb0, 0x52}; // Qualcomm Vendor MME code
} __attribute__((packed)) cm_reset_device_req;

typedef struct {
    uint8_t vendor_mme[3]; // Vendor MME code
    uint8_t success;
} __attribute__((packed)) cm_reset_device_cnf;

typedef struct {
    uint8_t vendor_mme[3] = {0x00, 0xb0, 0x52}; // Qualcomm Vendor MME code
} __attribute__((packed)) link_status_req;

typedef struct {
    uint8_t vendor_mme[3]; // Vendor MME code
    uint8_t reserved;
    uint8_t link_status;
} __attribute__((packed)) link_status_cnf;

typedef struct {
    uint8_t vendor_mme[3] = {0x00, 0xb0, 0x52}; // Qualcomm Vendor MME code
    uint32_t cookie{0x12345};                   // some cookie we will also get in the reply
    uint8_t report_type{0};                     // binary report
} __attribute__((packed)) op_attr_req;

typedef struct {
    uint8_t vendor_mme[3]; // Vendor MME code
    uint16_t success;      // 0x00 means success
    uint32_t cookie;
    uint8_t report_type; // should be 0x00 (binary)
    uint16_t size;       // should be 118, otherwise we do not know the structure
    uint8_t hw_platform[16];
    uint8_t sw_platform[16];
    uint32_t version_major;
    uint32_t version_minor;
    uint32_t version_pib;
    uint32_t version_build;
    uint32_t reserved;
    uint8_t build_date[8];
    uint8_t release_type[12];
    uint8_t sdram_type;
    uint8_t reserved2;
    uint8_t line_freq_zc;
    uint32_t sdram_size;
    uint8_t authorization_mode;
} __attribute__((packed)) op_attr_cnf;

} // namespace qualcomm

namespace lumissil {

typedef struct {
    uint16_t version;
    uint32_t reserved;
    uint8_t request_id;
    uint8_t reserved2[12];
} __attribute__((packed)) lms_header;

typedef struct {
    uint8_t vendor_mme[3] = {0x00, 0x16, 0xE8}; // Lumissil Vendor MME code
    lms_header lms;
    uint8_t mode{0}; // Normal reset
} __attribute__((packed)) nscm_reset_device_req;

typedef struct {
    uint8_t vendor_mme[3] = {0x00, 0x16, 0xE8}; // Lumissil Vendor MME code
    lms_header lms;
} __attribute__((packed)) nscm_get_version_req;

typedef struct {
    uint8_t vendor_mme[3] = {0x00, 0x16, 0xE8}; // Lumissil Vendor MME code
    lms_header lms;
    uint16_t version_major;
    uint16_t version_minor;
    uint16_t version_patch;
    uint16_t version_build;
    uint16_t reserved;
} __attribute__((packed)) nscm_get_version_cnf;

typedef struct {
    uint8_t vendor_mme[3] = {0x00, 0x16, 0xE8}; // Lumissil Vendor MME code
    lms_header lms;
} __attribute__((packed)) nscm_get_d_link_status_req;

typedef struct {
    uint8_t vendor_mme[3] = {0x00, 0x16, 0xE8}; // Lumissil Vendor MME code
    lms_header lms;
    uint8_t link_status;
} __attribute__((packed)) nscm_get_d_link_status_cnf;

// There is no CNF for this reset packet

} // namespace lumissil

} // namespace messages
} // namespace slac

#endif // SLAC_SLAC_HPP


// ===== include\slac\transport.hpp =====
#ifndef SLAC_TRANSPORT_HPP
#define SLAC_TRANSPORT_HPP

#include "port/port_common.hpp"

#include <cstddef>
#include <cstdint>

namespace slac::transport {

enum class LinkError {
    Ok,
    Timeout,
    Transport,
};

class Link {
public:
    virtual bool open() = 0;
    virtual bool write(const uint8_t* buf, size_t len, uint32_t timeout_ms) = 0;
    virtual LinkError read(uint8_t* buf, size_t len, size_t* out_len, uint32_t timeout_ms) = 0;
    virtual const uint8_t* mac() const = 0;
    virtual ~Link() = default;
};
} // namespace slac::transport

#endif // SLAC_TRANSPORT_HPP


// ===== port\esp32s3\endian_compat.hpp =====
#ifndef SLAC_ENDIAN_COMPAT_HPP
#define SLAC_ENDIAN_COMPAT_HPP

#include <stdint.h>

#ifndef htons
static inline uint16_t htons(uint16_t x) { return (x << 8) | (x >> 8); }
#endif
#ifndef ntohs
static inline uint16_t ntohs(uint16_t x) { return htons(x); }
#endif

#endif // SLAC_ENDIAN_COMPAT_HPP


// ===== port\esp32s3\ethernet_defs.hpp =====
#ifndef SLAC_ETHERNET_DEFS_HPP
#define SLAC_ETHERNET_DEFS_HPP

#include "../port_common.hpp"
#ifdef ESP_PLATFORM
#include "port_config.hpp"
#endif

#include <stdint.h>

#define ETH_ALEN 6
#define ETH_HLEN 14
#define ETH_FRAME_LEN 1514

struct ether_header {
    uint8_t ether_dhost[ETH_ALEN];
    uint8_t ether_shost[ETH_ALEN];
    uint16_t ether_type;
} __attribute__((packed));

#endif // SLAC_ETHERNET_DEFS_HPP


// ===== port\esp32s3\port_config.hpp =====
#ifndef SLAC_PORT_CONFIG_HPP
#define SLAC_PORT_CONFIG_HPP

#include "../port_common.hpp"

#ifdef ESP_PLATFORM
#include <stdint.h>

namespace slac {
inline uint16_t le16toh(uint16_t v) {
    return v;
}
inline uint16_t htole16(uint16_t v) {
    return v;
}
inline uint32_t le32toh(uint32_t v) {
    return v;
}
inline uint32_t htole32(uint32_t v) {
    return v;
}
} // namespace slac

#include <esp_timer.h>
#include <freertos/FreeRTOS.h>
#include <freertos/portmacro.h>
#include <freertos/task.h>

static inline uint32_t slac_millis() {
    return (uint32_t)(esp_timer_get_time() / 1000ULL);
}
static inline void slac_delay(uint32_t ms) {
    vTaskDelay(pdMS_TO_TICKS(ms));
}
static inline void slac_noInterrupts() {
    portDISABLE_INTERRUPTS();
}
static inline void slac_interrupts() {
    portENABLE_INTERRUPTS();
}
#endif // ESP_PLATFORM

#endif // SLAC_PORT_CONFIG_HPP


// ===== port\esp32s3\qca7000.cpp =====
#include "qca7000.hpp"
#include "../port_common.hpp"
#include "port_config.hpp"
#ifdef ESP_LOGW
#pragma push_macro("ESP_LOGW")
#undef ESP_LOGW
#define RESTORE_ESP_LOGW
#endif
#include "../logging_compat.hpp"
#ifdef RESTORE_ESP_LOGW
#pragma pop_macro("ESP_LOGW")
#undef RESTORE_ESP_LOGW
#endif
#include <arpa/inet.h>
#include <stdint.h>
#ifndef ESP_PLATFORM
static inline uint32_t esp_random() {
    return 0x12345678u;
}
#endif
#include <slac/slac.hpp>
#include <slac/iso15118_consts.hpp>
#include <slac/fsm.hpp>
#include <string.h>
#include <atomic>

const char* PLC_TAG = "PLC_IF";

uint8_t myethtransmitbuffer[V2GTP_BUFFER_SIZE]{};
size_t myethtransmitlen = 0;
uint8_t myethreceivebuffer[V2GTP_BUFFER_SIZE]{};
size_t myethreceivelen = 0;

static constexpr uint16_t SIG = 0xAA55;
static constexpr uint16_t WRBUF_RST = 0x0C5B;
static constexpr uint32_t FAST_HZ = 8000000;
static constexpr uint32_t SLOW_HZ = 1000000;
static constexpr uint16_t SOF_WORD = 0xAAAA;
static constexpr uint16_t EOF_WORD = 0x5555;
static constexpr uint16_t TX_HDR = 8;
static constexpr uint16_t RX_HDR = 12;
static constexpr uint16_t FTR_LEN = 2;
static constexpr uint16_t INTR_MASK = SPI_INT_CPU_ON | SPI_INT_PKT_AVLBL | SPI_INT_RDBUF_ERR | SPI_INT_WRBUF_ERR;

using FSMBuffer = slac::fsm::buffer::SwapBuffer<64, 0, 1>;
using FSM = slac::fsm::FSM<slac::SlacEvent, int, FSMBuffer>;

struct SlacContext {
    uint8_t run_id[slac::defs::RUN_ID_LEN]{};
    uint32_t timer{0};
    uint8_t sound_sent{0};
    uint8_t result{0};
};

static FSMBuffer g_fsm_buf{};
static SlacContext g_slac_ctx{};
static FSM g_fsm(g_fsm_buf);

struct ErrorCallbackCtx {
    qca7000_error_cb_t cb{nullptr};
    void* arg{nullptr};
    bool* flag{nullptr};
};
static ErrorCallbackCtx g_err_cb;

void qca7000SetErrorCallback(qca7000_error_cb_t cb, void* arg, bool* flag) {
    g_err_cb.cb = cb;
    g_err_cb.arg = arg;
    g_err_cb.flag = flag;
}

#ifdef LIBSLAC_TESTING
SPIClass* g_spi = nullptr;
int g_cs = -1;
int g_rst = PLC_SPI_RST_PIN;
#else
static SPIClass* g_spi = nullptr;
static int g_cs = -1;
static int g_rst = PLC_SPI_RST_PIN;
#endif
static SPISettings setSlow(SLOW_HZ, MSBFIRST, SPI_MODE3);
static SPISettings setFast(FAST_HZ, MSBFIRST, SPI_MODE3);

namespace {
struct RxEntry {
    size_t len;
    uint8_t data[V2GTP_BUFFER_SIZE];
};
static constexpr uint8_t RING_SIZE = 4;
static constexpr uint8_t RING_MASK = RING_SIZE - 1;
static RxEntry ring[RING_SIZE];
static std::atomic<uint8_t> head{0}, tail{0};

inline bool ringEmpty() {
    return head.load(std::memory_order_acquire) ==
           tail.load(std::memory_order_acquire);
}

inline void ringPush(const uint8_t* d, size_t l) {
    if (l > V2GTP_BUFFER_SIZE)
        l = V2GTP_BUFFER_SIZE;
    auto h = head.load(std::memory_order_acquire);
    auto t = tail.load(std::memory_order_acquire);
    uint8_t next = (h + 1) & RING_MASK;
    if (next == t) {
        ESP_LOGW(PLC_TAG, "RX ring full - dropping frame");
        return;
    }
    memcpy(ring[h].data, d, l);
    ring[h].len = l;
    head.store(next, std::memory_order_release);
}

inline bool ringPop(const uint8_t** d, size_t* l) {
    auto t = tail.load(std::memory_order_acquire);
    if (head.load(std::memory_order_acquire) == t)
        return false;
    *d = ring[t].data;
    *l = ring[t].len;
    tail.store((t + 1) & RING_MASK, std::memory_order_release);
    return true;
}
} // namespace

static inline uint16_t cmd16(bool rd, bool intr, uint16_t reg) {
    return (rd ? 0x8000u : 0) | (intr ? 0x4000u : 0) |
           (reg & 0x3FFFu);
}

static uint16_t spiRd16_fast(uint16_t reg) {
    g_spi->beginTransaction(setFast);
    digitalWrite(g_cs, LOW);
    g_spi->transfer16(cmd16(true, true, reg));
    uint16_t v = g_spi->transfer16(0);
    digitalWrite(g_cs, HIGH);
    g_spi->endTransaction();
    return v;
}

static void spiWr16_fast(uint16_t reg, uint16_t val) {
    g_spi->beginTransaction(setFast);
    digitalWrite(g_cs, LOW);
    g_spi->transfer16(cmd16(false, true, reg));
    g_spi->transfer16(val);
    digitalWrite(g_cs, HIGH);
    g_spi->endTransaction();
}

static bool hardReset() {
    pinMode(g_rst, OUTPUT);
    digitalWrite(g_rst, LOW);
    slac_delay(10);
    digitalWrite(g_rst, HIGH);
    slac_delay(100);

    auto slowRd16 = [&](uint16_t reg) -> uint16_t {
        g_spi->beginTransaction(setSlow);
        digitalWrite(g_cs, LOW);
        g_spi->transfer16(cmd16(true, true, reg));
        uint16_t v = g_spi->transfer16(0);
        digitalWrite(g_cs, HIGH);
        g_spi->endTransaction();
        return v;
    };

    uint32_t t0 = slac_millis();
    uint16_t sig = 0, buf = 0;
    do {
        sig = slowRd16(SPI_REG_SIGNATURE);
        buf = slowRd16(SPI_REG_WRBUF_SPC_AVA);
        if (sig == SIG && buf == WRBUF_RST)
            break;
        slac_delay(5);
    } while (slac_millis() - t0 < 200);

    if (sig != SIG || buf != WRBUF_RST) {
        ESP_LOGE(PLC_TAG, "Reset probe failed (SIG=0x%04X BUF=0x%04X)", sig, buf);
        return false;
    }
    ESP_LOGI(PLC_TAG, "Reset probe OK (SIG=0x%04X)", sig);

    t0 = slac_millis();
    while (!(slowRd16(SPI_REG_INTR_CAUSE) & SPI_INT_CPU_ON) && slac_millis() - t0 < 80)
        ;

    spiWr16_fast(SPI_REG_INTR_CAUSE, 0xFFFF);
    return true;
}

uint16_t qca7000ReadInternalReg(uint16_t r) {
    return spiRd16_fast(r);
}
bool qca7000ReadSignature(uint16_t* s, uint16_t* v) {
    uint16_t sig = qca7000ReadInternalReg(SPI_REG_SIGNATURE),
             ver = qca7000ReadInternalReg(0x1B00);
    if (s)
        *s = sig;
    if (v)
        *v = ver;
    return sig == SIG;
}

#ifdef LIBSLAC_TESTING
bool txFrame(const uint8_t* eth, size_t ethLen) {
#else
static bool txFrame(const uint8_t* eth, size_t ethLen) {
#endif
    if (ethLen > 1522)
        return false;
    size_t frameLen = ethLen;
    if (frameLen < 60)
        frameLen = 60;
    uint16_t spiLen = TX_HDR + frameLen + FTR_LEN;
    if (spiRd16_fast(SPI_REG_WRBUF_SPC_AVA) < spiLen)
        return false;

    spiWr16_fast(SPI_REG_BFR_SIZE, spiLen);

    g_spi->beginTransaction(setFast);
    digitalWrite(g_cs, LOW);
    g_spi->transfer16(cmd16(false, false, 0));
    g_spi->transfer16(SOF_WORD);
    g_spi->transfer16(SOF_WORD);
    g_spi->transfer16(slac::htole16(static_cast<uint16_t>(frameLen)));
    g_spi->transfer16(0);
    if (ethLen)
        g_spi->writeBytes(eth, ethLen);
    if (frameLen > ethLen) {
        uint8_t pad[60]{};
        g_spi->writeBytes(pad, frameLen - ethLen);
    }
    g_spi->transfer16(EOF_WORD);
    digitalWrite(g_cs, HIGH);
    g_spi->endTransaction();
    return true;
}
#ifdef LIBSLAC_TESTING
void fetchRx() {
#else
static void fetchRx() {
#endif
    uint16_t avail = spiRd16_fast(SPI_REG_RDBUF_BYTE_AVA);
    if (avail < RX_HDR + FTR_LEN || avail > V2GTP_BUFFER_SIZE)
        return;

    uint16_t requested = avail;
    spiWr16_fast(SPI_REG_BFR_SIZE, requested);

    static uint8_t buf[V2GTP_BUFFER_SIZE + 2];
    g_spi->beginTransaction(setFast);
    digitalWrite(g_cs, LOW);
    g_spi->transfer16(cmd16(true, false, 0));
    for (uint16_t i = 0; i < avail + 2; ++i)
        buf[i] = g_spi->transfer(0);
    digitalWrite(g_cs, HIGH);
    g_spi->endTransaction();

    const uint8_t* p = buf + 2;
    uint32_t len = (uint32_t)p[0] | ((uint32_t)p[1] << 8) | ((uint32_t)p[2] << 16) | ((uint32_t)p[3] << 24);
    if (len != requested) {
        ESP_LOGE(PLC_TAG, "RX len mismatch: req=%u got=%u", requested, len);
        return;
    }
    if (memcmp(p + 4, "\xAA\xAA\xAA\xAA", 4) != 0)
        return;
    uint16_t fl = slac::le16toh(static_cast<uint16_t>((p[9] << 8) | p[8]));
    if (fl > avail - RX_HDR - FTR_LEN)
        return;
    if (p[RX_HDR + fl] != 0x55 || p[RX_HDR + fl + 1] != 0x55)
        return;
    ringPush(p + RX_HDR, fl);
}

bool spiQCA7000SendEthFrame(const uint8_t* f, size_t l) {
    bool ok = txFrame(f, l);
    if (ok && l <= V2GTP_BUFFER_SIZE) {
        memcpy(myethtransmitbuffer, f, l);
        myethtransmitlen = l;
    }
    return ok;
}
size_t spiQCA7000checkForReceivedData(uint8_t* d, size_t m) {
    fetchRx();
    const uint8_t* s;
    size_t l;
    if (!ringPop(&s, &l))
        return 0;
    size_t c = l > m ? m : l;
    memcpy(d, s, c);
    size_t store = l;
    if (l > V2GTP_BUFFER_SIZE) {
        ESP_LOGW(PLC_TAG,
                 "RX frame larger than buffer (%zu > %d) - truncating",
                 l, V2GTP_BUFFER_SIZE);
        store = V2GTP_BUFFER_SIZE;
    }
    memcpy(myethreceivebuffer, s, store);
    myethreceivelen = store;
    return c;
}

static uint8_t g_run_id[slac::defs::RUN_ID_LEN]{};
static const uint8_t g_src_mac[ETH_ALEN] = {0x02, 0x00, 0x00, 0x00, 0x00, 0x01};

static bool send_start_atten_char(const SlacContext& ctx);
static bool send_mnbc_sound(const SlacContext& ctx, uint8_t remaining);
static bool send_atten_char_rsp(const SlacContext& ctx,
                                const uint8_t* dst,
                                const slac::messages::cm_atten_char_ind* ind);
static bool send_set_key_cnf(const SlacContext& ctx,
                             const uint8_t* dst,
                             const slac::messages::cm_set_key_req* req);

static bool send_start_atten_char(const SlacContext& ctx) {
    struct __attribute__((packed)) {
        ether_header eth;
        struct {
            uint8_t mmv;
            uint16_t mmtype;
        } hp;
        slac::messages::cm_start_atten_char_ind ind;
    } msg{};

    memset(&msg, 0, sizeof(msg));
    memset(msg.eth.ether_dhost, 0xFF, ETH_ALEN);
    memcpy(msg.eth.ether_shost, g_src_mac, ETH_ALEN);
    msg.eth.ether_type = htons(slac::defs::ETH_P_HOMEPLUG_GREENPHY);
    msg.hp.mmv = static_cast<uint8_t>(slac::defs::MMV::AV_1_0);
    msg.hp.mmtype = slac::htole16(slac::defs::MMTYPE_CM_START_ATTEN_CHAR |
                            slac::defs::MMTYPE_MODE_IND);
    msg.ind.application_type = slac::defs::COMMON_APPLICATION_TYPE;
    msg.ind.security_type = slac::defs::COMMON_SECURITY_TYPE;
    msg.ind.num_sounds = slac::defs::C_EV_MATCH_MNBC;
    msg.ind.timeout = slac::defs::TT_EVSE_MATCH_MNBC_MS / 100;
    msg.ind.resp_type = slac::defs::CM_SLAC_PARM_CNF_RESP_TYPE;
    memcpy(msg.ind.forwarding_sta, g_src_mac, ETH_ALEN);
    memcpy(msg.ind.run_id, ctx.run_id, sizeof(ctx.run_id));
    return txFrame(reinterpret_cast<uint8_t*>(&msg), sizeof(msg));
}

static bool send_mnbc_sound(const SlacContext& ctx, uint8_t remaining) {
    struct __attribute__((packed)) {
        ether_header eth;
        struct {
            uint8_t mmv;
            uint16_t mmtype;
        } hp;
        slac::messages::cm_mnbc_sound_ind ind;
    } msg{};

    memset(&msg, 0, sizeof(msg));
    memset(msg.eth.ether_dhost, 0xFF, ETH_ALEN);
    memcpy(msg.eth.ether_shost, g_src_mac, ETH_ALEN);
    msg.eth.ether_type = htons(slac::defs::ETH_P_HOMEPLUG_GREENPHY);
    msg.hp.mmv = static_cast<uint8_t>(slac::defs::MMV::AV_1_0);
    msg.hp.mmtype = slac::htole16(slac::defs::MMTYPE_CM_MNBC_SOUND |
                            slac::defs::MMTYPE_MODE_IND);
    msg.ind.application_type = slac::defs::COMMON_APPLICATION_TYPE;
    msg.ind.security_type = slac::defs::COMMON_SECURITY_TYPE;
    memset(msg.ind.sender_id, 0, sizeof(msg.ind.sender_id));
    msg.ind.remaining_sound_count = remaining;
    memcpy(msg.ind.run_id, ctx.run_id, sizeof(ctx.run_id));
    for (uint8_t& b : msg.ind.random)
        b = static_cast<uint8_t>(esp_random() & 0xFF);
    return txFrame(reinterpret_cast<uint8_t*>(&msg), sizeof(msg));
}

static bool send_atten_char_rsp(const SlacContext& ctx,
                                const uint8_t* dst,
                                const slac::messages::cm_atten_char_ind* ind) {
    struct __attribute__((packed)) {
        ether_header eth;
        struct {
            uint8_t mmv;
            uint16_t mmtype;
        } hp;
        slac::messages::cm_atten_char_rsp rsp;
    } msg{};

    memset(&msg, 0, sizeof(msg));
    memcpy(msg.eth.ether_dhost, dst, ETH_ALEN);
    memcpy(msg.eth.ether_shost, g_src_mac, ETH_ALEN);
    msg.eth.ether_type = htons(slac::defs::ETH_P_HOMEPLUG_GREENPHY);
    msg.hp.mmv = static_cast<uint8_t>(slac::defs::MMV::AV_1_0);
    msg.hp.mmtype = slac::htole16(slac::defs::MMTYPE_CM_ATTEN_CHAR |
                            slac::defs::MMTYPE_MODE_RSP);
    msg.rsp.application_type = slac::defs::COMMON_APPLICATION_TYPE;
    msg.rsp.security_type = slac::defs::COMMON_SECURITY_TYPE;
    memcpy(msg.rsp.source_address, g_src_mac, ETH_ALEN);
    memcpy(msg.rsp.run_id, ind->run_id, sizeof(ind->run_id));
    memcpy(msg.rsp.source_id, ind->source_id, sizeof(ind->source_id));
    memcpy(msg.rsp.resp_id, ind->resp_id, sizeof(ind->resp_id));
    msg.rsp.result = slac::defs::CM_ATTEN_CHAR_RSP_RESULT;
    return txFrame(reinterpret_cast<uint8_t*>(&msg), sizeof(msg));
}

static bool send_set_key_cnf(const SlacContext& ctx,
                             const uint8_t* dst,
                             const slac::messages::cm_set_key_req* req) {
    struct __attribute__((packed)) {
        ether_header eth;
        struct {
            uint8_t mmv;
            uint16_t mmtype;
        } hp;
        slac::messages::cm_set_key_cnf cnf;
    } msg{};

    memset(&msg, 0, sizeof(msg));
    memcpy(msg.eth.ether_dhost, dst, ETH_ALEN);
    memcpy(msg.eth.ether_shost, g_src_mac, ETH_ALEN);
    msg.eth.ether_type = htons(slac::defs::ETH_P_HOMEPLUG_GREENPHY);
    msg.hp.mmv = static_cast<uint8_t>(slac::defs::MMV::AV_1_0);
    msg.hp.mmtype = slac::htole16(slac::defs::MMTYPE_CM_SET_KEY |
                            slac::defs::MMTYPE_MODE_CNF);
    msg.cnf.result = slac::defs::CM_SET_KEY_CNF_RESULT_SUCCESS;
    msg.cnf.my_nonce = req->my_nonce;
    msg.cnf.your_nonce = req->your_nonce;
    msg.cnf.pid = req->pid;
    msg.cnf.prn = req->prn;
    msg.cnf.pmn = req->pmn;
    msg.cnf.cco_capability = req->cco_capability;
    return txFrame(reinterpret_cast<uint8_t*>(&msg), sizeof(msg));
}

// FSM state implementations
struct SoundingState;
struct WaitSetKeyState;
struct WaitMatchState;
struct IdleState : public FSM::SimpleStateType {
    SlacContext& ctx;
    IdleState(SlacContext& c) : ctx(c) {}
    void enter() override { ctx.result = 0; }
    fsm::states::HandleEventResult handle_event(FSM::StateAllocatorType&, slac::SlacEvent) override {
        return FSM::StateAllocatorType::PASS_ON;
    }
};

struct WaitParmCnfState : public FSM::SimpleStateType {
    SlacContext& ctx;
    WaitParmCnfState(SlacContext& c) : ctx(c) {}
    void enter() override { ctx.result = 1; ctx.sound_sent = 0; ctx.timer = slac_millis(); }
    fsm::states::HandleEventResult handle_event(FSM::StateAllocatorType& alloc, slac::SlacEvent ev) override {
        if (ev == slac::SlacEvent::GotParmCnf) {
            send_start_atten_char(ctx);
            ctx.timer = slac_millis();
            ctx.result = 2;
            return alloc.create_simple<SoundingState>(ctx);
        }
        if (ev == slac::SlacEvent::Timeout || ev == slac::SlacEvent::Error) {
            ctx.result = 0xFF;
            return alloc.create_simple<IdleState>(ctx);
        }
        return FSM::StateAllocatorType::PASS_ON;
    }
};

struct SoundingState : public FSM::SimpleStateType {
    SlacContext& ctx;
    SoundingState(SlacContext& c) : ctx(c) {}
    void enter() override { ctx.result = 2; }
    fsm::states::HandleEventResult handle_event(FSM::StateAllocatorType& alloc, slac::SlacEvent ev) override {
        if (ev == slac::SlacEvent::SoundIntervalElapsed) {
            uint8_t remaining = slac::defs::C_EV_MATCH_MNBC - ctx.sound_sent - 1;
            send_mnbc_sound(ctx, remaining);
            ++ctx.sound_sent;
            return FSM::StateAllocatorType::HANDLED_INTERNALLY;
        }
        if (ev == slac::SlacEvent::GotAttenCharInd) {
            ctx.timer = slac_millis();
            ctx.result = 3;
            return alloc.create_simple<WaitSetKeyState>(ctx);
        }
        if (ev == slac::SlacEvent::Timeout || ev == slac::SlacEvent::Error) {
            ctx.result = 0xFF;
            return alloc.create_simple<IdleState>(ctx);
        }
        return FSM::StateAllocatorType::PASS_ON;
    }
};

struct WaitSetKeyState : public FSM::SimpleStateType {
    SlacContext& ctx;
    WaitSetKeyState(SlacContext& c) : ctx(c) {}
    void enter() override { ctx.result = 3; ctx.timer = slac_millis(); }
    fsm::states::HandleEventResult handle_event(FSM::StateAllocatorType& alloc, slac::SlacEvent ev) override {
        if (ev == slac::SlacEvent::GotSetKeyReq) {
            ctx.timer = slac_millis();
            ctx.result = 4;
            return alloc.create_simple<WaitMatchState>(ctx);
        }
        if (ev == slac::SlacEvent::Timeout || ev == slac::SlacEvent::Error) {
            ctx.result = 0xFF;
            return alloc.create_simple<IdleState>(ctx);
        }
        return FSM::StateAllocatorType::PASS_ON;
    }
};

struct WaitMatchState : public FSM::SimpleStateType {
    SlacContext& ctx;
    WaitMatchState(SlacContext& c) : ctx(c) {}
    void enter() override { ctx.result = 4; ctx.timer = slac_millis(); }
    fsm::states::HandleEventResult handle_event(FSM::StateAllocatorType& alloc, slac::SlacEvent ev) override {
        if (ev == slac::SlacEvent::GotMatchReq) {
            ctx.result = 5;
            return alloc.create_simple<IdleState>(ctx);
        }
        if (ev == slac::SlacEvent::Timeout || ev == slac::SlacEvent::Error) {
            ctx.result = 0xFF;
            return alloc.create_simple<IdleState>(ctx);
        }
        return FSM::StateAllocatorType::PASS_ON;
    }
};

// Issue a CM_SLAC_PARM.REQ to start the SLAC matching handshake.
bool qca7000startSlac() {
    g_slac_ctx.result = 1;
    g_slac_ctx.timer = slac_millis();
    g_slac_ctx.sound_sent = 0;

    for (size_t i = 0; i < sizeof(g_slac_ctx.run_id); ++i)
        g_slac_ctx.run_id[i] = static_cast<uint8_t>(esp_random() & 0xFF);

    struct __attribute__((packed)) {
        ether_header eth;
        struct {
            uint8_t mmv;
            uint16_t mmtype;
        } hp;
        slac::messages::cm_slac_parm_req req;
    } msg{};

    memset(&msg, 0, sizeof(msg));
    memset(msg.eth.ether_dhost, 0xFF, ETH_ALEN);
    memcpy(msg.eth.ether_shost, g_src_mac, ETH_ALEN);
    msg.eth.ether_type = htons(slac::defs::ETH_P_HOMEPLUG_GREENPHY);
    msg.hp.mmv = static_cast<uint8_t>(slac::defs::MMV::AV_1_0);
    msg.hp.mmtype = slac::htole16(slac::defs::MMTYPE_CM_SLAC_PARAM | slac::defs::MMTYPE_MODE_REQ);
    msg.req.application_type = slac::defs::COMMON_APPLICATION_TYPE;
    msg.req.security_type = slac::defs::COMMON_SECURITY_TYPE;
    memcpy(msg.req.run_id, g_slac_ctx.run_id, sizeof(g_slac_ctx.run_id));

    bool ok = txFrame(reinterpret_cast<uint8_t*>(&msg), sizeof(msg));
    if (ok)
        g_fsm.reset<WaitParmCnfState>(g_slac_ctx);
    else
        g_fsm.reset<IdleState>(g_slac_ctx);
    return ok;
}

// Poll for SLAC confirmation frames and update state accordingly.
uint8_t qca7000getSlacResult() {
    fetchRx();
    const uint32_t now = slac_millis();
    const uint8_t* d;
    size_t l;
    while (ringPop(&d, &l)) {
        if (l < sizeof(ether_header) + 3)
            continue;
        const ether_header* eth = reinterpret_cast<const ether_header*>(d);
        if (eth->ether_type != htons(slac::defs::ETH_P_HOMEPLUG_GREENPHY))
            continue;
        const uint8_t* p = d + sizeof(ether_header);
        uint8_t mmv = p[0];
        uint16_t mmtype = slac::le16toh(*reinterpret_cast<const uint16_t*>(p + 1));
        if (mmv != static_cast<uint8_t>(slac::defs::MMV::AV_1_0))
            continue;

        if (mmtype == (slac::defs::MMTYPE_CM_SLAC_PARAM | slac::defs::MMTYPE_MODE_CNF)) {
            const auto* cnf = reinterpret_cast<const slac::messages::cm_slac_parm_cnf*>(p + 3);
            if (!memcmp(cnf->run_id, g_slac_ctx.run_id, sizeof(g_slac_ctx.run_id))) {
                g_fsm.handle_event(slac::SlacEvent::GotParmCnf);
            } else {
                g_fsm.handle_event(slac::SlacEvent::Error);
            }
        } else if (mmtype == (slac::defs::MMTYPE_CM_ATTEN_CHAR | slac::defs::MMTYPE_MODE_IND)) {
            const auto* ind = reinterpret_cast<const slac::messages::cm_atten_char_ind*>(p + 3);
            if (!memcmp(ind->run_id, g_slac_ctx.run_id, sizeof(g_slac_ctx.run_id))) {
                send_atten_char_rsp(g_slac_ctx, eth->ether_shost, ind);
                g_fsm.handle_event(slac::SlacEvent::GotAttenCharInd);
            } else {
                g_fsm.handle_event(slac::SlacEvent::Error);
            }
        } else if (mmtype == (slac::defs::MMTYPE_CM_SET_KEY | slac::defs::MMTYPE_MODE_REQ)) {
            const auto* req = reinterpret_cast<const slac::messages::cm_set_key_req*>(p + 3);
            send_set_key_cnf(g_slac_ctx, eth->ether_shost, req);
            g_fsm.handle_event(slac::SlacEvent::GotSetKeyReq);
        } else if (mmtype == (slac::defs::MMTYPE_CM_SLAC_MATCH | slac::defs::MMTYPE_MODE_REQ)) {
            const auto* req = reinterpret_cast<const slac::messages::cm_slac_match_req*>(p + 3);
            if (!memcmp(req->run_id, g_slac_ctx.run_id, sizeof(g_slac_ctx.run_id)))
                g_fsm.handle_event(slac::SlacEvent::GotMatchReq);
            else
                g_fsm.handle_event(slac::SlacEvent::Error);
        }
    }

    if (g_slac_ctx.result == 2) {
        if (g_slac_ctx.sound_sent < slac::defs::C_EV_MATCH_MNBC &&
            now - g_slac_ctx.timer >= slac::defs::TP_EV_BATCH_MSG_INTERVAL_MS) {
            g_fsm.handle_event(slac::SlacEvent::SoundIntervalElapsed);
            g_slac_ctx.timer = now;
            if (g_slac_ctx.sound_sent == slac::defs::C_EV_MATCH_MNBC)
                g_slac_ctx.timer = now; // start wait for ATTEN_CHAR
        }
        if (g_slac_ctx.sound_sent == slac::defs::C_EV_MATCH_MNBC &&
            now - g_slac_ctx.timer > slac::defs::TT_EV_ATTEN_RESULTS_MS)
            g_fsm.handle_event(slac::SlacEvent::Timeout);
    } else if (g_slac_ctx.result == 3 && now - g_slac_ctx.timer > slac::defs::TT_MATCH_SEQUENCE_MS) {
        g_fsm.handle_event(slac::SlacEvent::Timeout);
    } else if (g_slac_ctx.result == 4 && now - g_slac_ctx.timer > slac::defs::TT_MATCH_JOIN_MS) {
        g_fsm.handle_event(slac::SlacEvent::Timeout);
    }

    return g_slac_ctx.result;
}

void qca7000Process() {
    spiWr16_fast(SPI_REG_INTR_ENABLE, 0);
    while (true) {
        uint16_t cause = spiRd16_fast(SPI_REG_INTR_CAUSE);
        if (!cause)
            break;

        uint16_t clear_mask = 0;

        if (cause & SPI_INT_CPU_ON) {
            clear_mask |= SPI_INT_CPU_ON;
            hardReset();
            if (g_err_cb.flag)
                *g_err_cb.flag = true;
            if (g_err_cb.cb)
                g_err_cb.cb(g_err_cb.arg);
            qca7000setup(g_spi, g_cs, g_rst);
            spiWr16_fast(SPI_REG_INTR_CAUSE, clear_mask);
            spiWr16_fast(SPI_REG_INTR_ENABLE, INTR_MASK);
            return;
        }
        if (cause & (SPI_INT_WRBUF_ERR | SPI_INT_RDBUF_ERR)) {
            clear_mask |= SPI_INT_WRBUF_ERR | SPI_INT_RDBUF_ERR;
            hardReset();
            if (g_err_cb.flag)
                *g_err_cb.flag = true;
            if (g_err_cb.cb)
                g_err_cb.cb(g_err_cb.arg);
            spiWr16_fast(SPI_REG_INTR_CAUSE, clear_mask);
            spiWr16_fast(SPI_REG_INTR_ENABLE, INTR_MASK);
            return;
        }
        if (cause & SPI_INT_PKT_AVLBL) {
            fetchRx();
            clear_mask |= SPI_INT_PKT_AVLBL;
        }

        if (clear_mask)
            spiWr16_fast(SPI_REG_INTR_CAUSE, clear_mask);
    }
    spiWr16_fast(SPI_REG_INTR_ENABLE, INTR_MASK);
}

bool qca7000setup(SPIClass* bus, int csPin, int rstPin) {
    ESP_LOGI(PLC_TAG, "QCA7000 setup: bus=%p CS=%d RST=%d", bus, csPin, rstPin);
    g_spi = bus;
    g_cs = csPin;
    g_rst = rstPin;
    if (g_spi)
        g_spi->begin();
    pinMode(g_cs, OUTPUT);
    digitalWrite(g_cs, HIGH);

    if (!hardReset()) {
        ESP_LOGE(PLC_TAG, "hardReset failed – modem missing");
        return false;
    }

    spiWr16_fast(SPI_REG_INTR_ENABLE, INTR_MASK);
    ESP_LOGI(PLC_TAG, "QCA7000 ready");
    return true;
}

void qca7000teardown() {
    if (g_spi) {
        g_spi->end();
    }
    g_spi = nullptr;
}

bool qca7000ResetAndCheck() {
    return hardReset();
}

#ifdef ESP_PLATFORM
#include <freertos/FreeRTOS.h>
#include <freertos/queue.h>
#include <freertos/task.h>
#include <slac/channel.hpp>

void qca7000_task(void* arg) {
    auto* ctx = static_cast<Qca7000TaskContext*>(arg);
    slac::messages::HomeplugMessage msg;

    while (true) {
        qca7000Process();
        if (ctx && ctx->channel && ctx->channel->poll(msg)) {
            if (ctx->queue) {
                xQueueSend(ctx->queue, &msg, 0);
            }
        }
        vTaskDelay(pdMS_TO_TICKS(1));
    }
}
#endif


// ===== port\esp32s3\qca7000.hpp =====
#pragma once

#include "../port_common.hpp"
#ifdef ESP_PLATFORM
#include "port_config.hpp"
#endif

#include "ethernet_defs.hpp"
#ifdef ARDUINO
#include <Arduino.h>
#include <SPI.h>
#endif
#include <slac/channel.hpp>
#include <stddef.h>
#include <stdint.h>

#ifndef V2GTP_BUFFER_SIZE
#define V2GTP_BUFFER_SIZE 1536
#endif

static_assert(ETH_FRAME_LEN <= V2GTP_BUFFER_SIZE,
              "ETH_FRAME_LEN must not exceed V2GTP_BUFFER_SIZE");

// Register and interrupt definitions (see QCA7000 datasheet)
#ifndef SPI_INT_CPU_ON
#define SPI_INT_CPU_ON 0x0040
#endif
#ifndef SPI_INT_PKT_AVLBL
#define SPI_INT_PKT_AVLBL 0x0001
#endif
#ifndef SPI_INT_RDBUF_ERR
#define SPI_INT_RDBUF_ERR 0x0002
#endif
#ifndef SPI_INT_WRBUF_ERR
#define SPI_INT_WRBUF_ERR 0x0004
#endif
#ifndef SPI_REG_SIGNATURE
#define SPI_REG_SIGNATURE 0x1A00
#endif
#ifndef SPI_REG_WRBUF_SPC_AVA
#define SPI_REG_WRBUF_SPC_AVA 0x0200
#endif
#ifndef SPI_REG_INTR_CAUSE
#define SPI_REG_INTR_CAUSE 0x0C00
#endif
#ifndef SPI_REG_BFR_SIZE
#define SPI_REG_BFR_SIZE 0x0100
#endif
#ifndef SPI_REG_RDBUF_BYTE_AVA
#define SPI_REG_RDBUF_BYTE_AVA 0x0300
#endif
#ifndef SPI_REG_INTR_ENABLE
#define SPI_REG_INTR_ENABLE 0x0D00
#endif

#ifndef PLC_SPI_RST_PIN
#define PLC_SPI_RST_PIN 5
#endif
#ifndef PLC_SPI_CS_PIN
#define PLC_SPI_CS_PIN 17
#endif

struct qca7000_config {
    SPIClass* spi;
    int cs_pin;
    int rst_pin{PLC_SPI_RST_PIN};
    const uint8_t* mac_addr{nullptr};
};

bool qca7000setup(SPIClass* spi, int cs_pin, int rst_pin = PLC_SPI_RST_PIN);
void qca7000teardown();
bool qca7000ResetAndCheck();
uint16_t qca7000ReadInternalReg(uint16_t reg);
bool qca7000ReadSignature(uint16_t* sig = nullptr, uint16_t* ver = nullptr);
size_t spiQCA7000checkForReceivedData(uint8_t* dst, size_t maxLen);
bool spiQCA7000SendEthFrame(const uint8_t* frame, size_t len);
bool qca7000startSlac();
uint8_t qca7000getSlacResult();
void qca7000Process();

typedef void (*qca7000_error_cb_t)(void*);
void qca7000SetErrorCallback(qca7000_error_cb_t cb, void* arg, bool* flag);
#ifdef ESP_PLATFORM
#include <freertos/FreeRTOS.h>
#include <freertos/queue.h>

struct Qca7000TaskContext {
    slac::Channel* channel;
    QueueHandle_t queue;
};

void qca7000_task(void* arg);
#endif

extern uint8_t myethtransmitbuffer[V2GTP_BUFFER_SIZE];
extern size_t myethtransmitlen;
extern uint8_t myethreceivebuffer[V2GTP_BUFFER_SIZE];
extern size_t myethreceivelen;
extern const char* PLC_TAG;


// ===== port\esp32s3\qca7000_link.cpp =====
#include "qca7000_link.hpp"
#include "../port_common.hpp"
#include "port_config.hpp"
#include "qca7000.hpp"
#include <cstring>

namespace slac {
namespace port {

Qca7000Link::Qca7000Link(const qca7000_config& c,
                         ErrorCallback cb,
                         void* cb_arg)
    : cfg(c), error_cb(cb), error_arg(cb_arg) {
    memset(mac_addr, 0, sizeof(mac_addr));
}

Qca7000Link::~Qca7000Link() {
    close();
    qca7000SetErrorCallback(nullptr, nullptr, nullptr);
}

void Qca7000Link::set_error_callback(ErrorCallback cb, void* arg) {
    error_cb = cb;
    error_arg = arg;
    qca7000SetErrorCallback(error_cb, error_arg, &fatal_error_flag);
}

bool Qca7000Link::open() {
    if (initialized)
        return true;
    if (initialization_error)
        return false;

    SPIClass* bus = cfg.spi ? cfg.spi : &SPI;
    int cs = cfg.cs_pin ? cfg.cs_pin : PLC_SPI_CS_PIN;
    int rst = cfg.rst_pin ? cfg.rst_pin : PLC_SPI_RST_PIN;

    if (ETH_FRAME_LEN > V2GTP_BUFFER_SIZE) {
        initialization_error = true;
        return false;
    }

    if (!qca7000setup(bus, cs, rst)) {
        initialization_error = true;
        return false;
    }
    qca7000SetErrorCallback(error_cb, error_arg, &fatal_error_flag);

    if (cfg.mac_addr)
        memcpy(mac_addr, cfg.mac_addr, ETH_ALEN);
    else {
        const uint8_t def_mac[ETH_ALEN] = {0x02, 0x00, 0x00, 0x00, 0x00, 0x01};
        memcpy(mac_addr, def_mac, ETH_ALEN);
    }
    initialized = true;
    return true;
}

bool Qca7000Link::write(const uint8_t* b, size_t l, uint32_t) {
    if (!initialized || initialization_error)
        return false;
    return spiQCA7000SendEthFrame(b, l);
}

void Qca7000Link::close() {
    if (!initialized)
        return;
    qca7000teardown();
    initialized = false;
}

transport::LinkError Qca7000Link::read(uint8_t* b, size_t l, size_t* out, uint32_t timeout_ms) {
    if (!initialized || initialization_error) {
        *out = 0;
        return transport::LinkError::Transport;
    }
    uint32_t start = slac_millis();
    do {
        size_t got = spiQCA7000checkForReceivedData(b, l);
        if (got) {
            *out = got;
            return transport::LinkError::Ok;
        }
        if (timeout_ms == 0)
            break;
        slac_delay(1);
    } while (slac_millis() - start < timeout_ms);
    *out = 0;
    return transport::LinkError::Timeout;
}

const uint8_t* Qca7000Link::mac() const {
    return mac_addr;
}

} // namespace port
} // namespace slac


// ===== port\esp32s3\qca7000_link.hpp =====
#ifndef SLAC_QCA7000_LINK_HPP
#define SLAC_QCA7000_LINK_HPP

#include "../port_common.hpp"
#ifdef ESP_PLATFORM
#include "port_config.hpp"
#endif

#include "ethernet_defs.hpp"
#include "qca7000.hpp"
#include <slac/transport.hpp>

namespace slac {
namespace port {

/**
 * @brief Link implementation for the QCA7000 powerline modem.
 *
 * \note Thread Safety: Qca7000Link is not thread-safe. The caller must
 * serialise access when used from multiple threads.
 */
class Qca7000Link : public transport::Link {
public:
    using ErrorCallback = qca7000_error_cb_t;

    explicit Qca7000Link(const qca7000_config& cfg,
                         ErrorCallback cb = nullptr,
                         void* cb_arg = nullptr);

    void set_error_callback(ErrorCallback cb, void* arg);
    bool fatal_error() const { return fatal_error_flag; }
    void clear_fatal_error() { fatal_error_flag = false; }

    ~Qca7000Link();

    /// Close the underlying bus and reset internal state
    void close();

    bool open() override;
    bool write(const uint8_t* b, size_t l, uint32_t timeout_ms) override;
    transport::LinkError read(uint8_t* b, size_t l, size_t* out, uint32_t timeout_ms) override;
    const uint8_t* mac() const override;

    /**
     * @brief Returns true if an initialization error has occurred.
     */
    bool init_failed() const {
        return initialization_error;
    }

    /**
     * @brief Returns true if the link was successfully opened.
     */
    bool is_initialized() const {
        return initialized;
    }

private:
    bool initialized{false};
    bool initialization_error{false};
    bool fatal_error_flag{false};
    ErrorCallback error_cb{nullptr};
    void* error_arg{nullptr};
    qca7000_config cfg;
    uint8_t mac_addr[ETH_ALEN]{};
};

} // namespace port
} // namespace slac

#endif // SLAC_QCA7000_LINK_HPP


// ===== port\esp32s3\qca7000_uart.cpp =====
#include "qca7000_uart.hpp"
#include "port_config.hpp"
#include "qca7000.hpp"
#include "../logging_compat.hpp"
#include <atomic>
#include <string.h>

static constexpr uint16_t SOF_WORD = 0xAAAA;
static constexpr uint16_t EOF_WORD = 0x5555;
static constexpr uint16_t TX_HDR = 8;
static constexpr uint16_t RX_HDR = 8;
static constexpr uint16_t FTR_LEN = 2;

#ifdef LIBSLAC_TESTING
HardwareSerial* g_serial = nullptr;
#else
static HardwareSerial* g_serial = nullptr;
#endif

namespace {
struct RxEntry {
    size_t len;
    uint8_t data[V2GTP_BUFFER_SIZE];
};
static constexpr uint8_t RING_SIZE = 4;
static constexpr uint8_t RING_MASK = RING_SIZE - 1;
static RxEntry ring[RING_SIZE];
static std::atomic<uint8_t> head{0}, tail{0};
inline bool ringEmpty() {
    return head.load(std::memory_order_acquire) == tail.load(std::memory_order_acquire);
}
static uint32_t last_rx_time = 0;
static uint32_t frame_timeout_ms = 0;
inline void ringPush(const uint8_t* d, size_t l) {
    if (l > V2GTP_BUFFER_SIZE)
        l = V2GTP_BUFFER_SIZE;
    auto h = head.load(std::memory_order_acquire);
    auto t = tail.load(std::memory_order_acquire);
    uint8_t next = (h + 1) & RING_MASK;
    if (next == t) {
        ESP_LOGW(PLC_TAG, "RX ring full - dropping frame");
        return;
    }
    memcpy(ring[h].data, d, l);
    ring[h].len = l;
    head.store(next, std::memory_order_release);
}
inline bool ringPop(const uint8_t** d, size_t* l) {
    auto t = tail.load(std::memory_order_acquire);
    if (head.load(std::memory_order_acquire) == t)
        return false;
    *d = ring[t].data;
    *l = ring[t].len;
    tail.store((t + 1) & RING_MASK, std::memory_order_release);
    return true;
}

static enum State {
    WAIT_SOF,
    LEN1,
    LEN2,
    RSVD1,
    RSVD2,
    PAYLOAD,
    EOF1,
    EOF2
} state = WAIT_SOF;
static size_t sof_count = 0;
static uint16_t rx_len = 0;
static uint16_t rx_pos = 0;
static uint8_t rx_buf[V2GTP_BUFFER_SIZE];

inline void processByte(uint8_t b) {
    switch (state) {
    case WAIT_SOF:
        if (b == 0xAA) {
            if (++sof_count == 4) {
                sof_count = 0;
                state = LEN1;
            }
        } else {
            sof_count = 0;
        }
        break;
    case LEN1:
        rx_len = b;
        state = LEN2;
        break;
    case LEN2:
        rx_len |= static_cast<uint16_t>(b) << 8;
        if (rx_len > V2GTP_BUFFER_SIZE) {
            state = WAIT_SOF;
            break;
        }
        state = RSVD1;
        break;
    case RSVD1:
        state = RSVD2;
        break;
    case RSVD2:
        rx_pos = 0;
        state = PAYLOAD;
        break;
    case PAYLOAD:
        rx_buf[rx_pos++] = b;
        if (rx_pos >= rx_len)
            state = EOF1;
        break;
    case EOF1:
        if (b == 0x55)
            state = EOF2;
        else
            state = WAIT_SOF;
        break;
    case EOF2:
        if (b == 0x55)
            ringPush(rx_buf, rx_len);
        state = WAIT_SOF;
        break;
    }
}

inline void pollRx() {
    uint32_t now = slac_millis();
    if (state != WAIT_SOF && frame_timeout_ms && now - last_rx_time > frame_timeout_ms) {
        state = WAIT_SOF;
        sof_count = 0;
        rx_pos = 0;
    }
    while (g_serial && g_serial->available()) {
        int v = g_serial->read();
        if (v < 0)
            break;
        processByte(static_cast<uint8_t>(v));
        last_rx_time = slac_millis();
    }
}
} // namespace

#ifdef LIBSLAC_TESTING
bool uartTxFrame(const uint8_t* eth, size_t ethLen) {
#else
static bool uartTxFrame(const uint8_t* eth, size_t ethLen) {
#endif
    if (!g_serial || ethLen > 1522)
        return false;
    size_t frameLen = ethLen;
    if (frameLen < 60)
        frameLen = 60;
    uint8_t hdr[TX_HDR];
    hdr[0] = hdr[1] = hdr[2] = hdr[3] = 0xAA;
    hdr[4] = frameLen & 0xFF;
    hdr[5] = (frameLen >> 8) & 0xFF;
    hdr[6] = 0;
    hdr[7] = 0;
    g_serial->write(hdr, TX_HDR);
    if (ethLen)
        g_serial->write(eth, ethLen);
    if (frameLen > ethLen) {
        uint8_t pad[60]{};
        g_serial->write(pad, frameLen - ethLen);
    }
    uint8_t eof[2] = {0x55, 0x55};
    g_serial->write(eof, 2);
    return true;
}

#ifdef LIBSLAC_TESTING
void uartFetchRx() {
#else
static void uartFetchRx() {
#endif
    pollRx();
}

void uartQca7000Teardown() {
#ifdef ARDUINO
    if (g_serial)
        g_serial->end();
#endif
    g_serial = nullptr;
    head.store(0, std::memory_order_release);
    tail.store(0, std::memory_order_release);
}

bool uartQCA7000SendEthFrame(const uint8_t* f, size_t l) {
    bool ok = uartTxFrame(f, l);
    if (ok && l <= V2GTP_BUFFER_SIZE) {
        memcpy(myethtransmitbuffer, f, l);
        myethtransmitlen = l;
    }
    return ok;
}

size_t uartQCA7000checkForReceivedData(uint8_t* d, size_t m) {
    pollRx();
    const uint8_t* s;
    size_t l;
    if (!ringPop(&s, &l))
        return 0;
    size_t c = l > m ? m : l;
    memcpy(d, s, c);
    size_t store = l;
    if (l > V2GTP_BUFFER_SIZE) {
        ESP_LOGW(PLC_TAG,
                 "RX frame larger than buffer (%zu > %d) - truncating",
                 l, V2GTP_BUFFER_SIZE);
        store = V2GTP_BUFFER_SIZE;
    }
    memcpy(myethreceivebuffer, s, store);
    myethreceivelen = store;
    return c;
}

namespace slac {
namespace port {

Qca7000UartLink::Qca7000UartLink(const qca7000_uart_config& c) : cfg(c) {
    memset(mac_addr, 0, sizeof(mac_addr));
}

Qca7000UartLink::~Qca7000UartLink() {
    close();
}

bool Qca7000UartLink::open() {
    if (initialized)
        return true;
    if (initialization_error)
        return false;

    g_serial = cfg.serial ? cfg.serial : &Serial;
    if (ETH_FRAME_LEN > V2GTP_BUFFER_SIZE) {
        initialization_error = true;
        return false;
    }
#ifdef ARDUINO
    if (g_serial) {
        uint32_t baud = cfg.baud ? cfg.baud : 115200;
        g_serial->begin(baud);
        uint64_t bits = static_cast<uint64_t>(V2GTP_BUFFER_SIZE + TX_HDR + FTR_LEN) * 10ULL;
        uint32_t base_timeout = static_cast<uint32_t>((bits * 1000ULL + baud - 1) / baud);
        frame_timeout_ms = base_timeout * 4; // add margin for RTS/CTS flow control
    }
#else
    uint32_t baud = cfg.baud ? cfg.baud : 115200;
    uint64_t bits = static_cast<uint64_t>(V2GTP_BUFFER_SIZE + TX_HDR + FTR_LEN) * 10ULL;
    uint32_t base_timeout = static_cast<uint32_t>((bits * 1000ULL + baud - 1) / baud);
    frame_timeout_ms = base_timeout * 4; // add margin for RTS/CTS flow control
#endif
    last_rx_time = slac_millis();
    if (cfg.mac_addr)
        memcpy(mac_addr, cfg.mac_addr, ETH_ALEN);
    else {
        const uint8_t def_mac[ETH_ALEN] = {0x02, 0x00, 0x00, 0x00, 0x00, 0x01};
        memcpy(mac_addr, def_mac, ETH_ALEN);
    }
    initialized = true;
    return true;
}

bool Qca7000UartLink::write(const uint8_t* b, size_t l, uint32_t) {
    if (!initialized || initialization_error)
        return false;
    return uartQCA7000SendEthFrame(b, l);
}

void Qca7000UartLink::close() {
    if (!initialized)
        return;
    uartQca7000Teardown();
    initialized = false;
}

transport::LinkError Qca7000UartLink::read(uint8_t* b, size_t l, size_t* out, uint32_t timeout_ms) {
    if (!initialized || initialization_error) {
        *out = 0;
        return transport::LinkError::Transport;
    }
    uint32_t start = slac_millis();
    do {
        size_t got = uartQCA7000checkForReceivedData(b, l);
        if (got) {
            *out = got;
            return transport::LinkError::Ok;
        }
        if (timeout_ms == 0)
            break;
        slac_delay(1);
    } while (slac_millis() - start < timeout_ms);
    *out = 0;
    return transport::LinkError::Timeout;
}

const uint8_t* Qca7000UartLink::mac() const {
    return mac_addr;
}

} // namespace port
} // namespace slac


// ===== port\esp32s3\qca7000_uart.hpp =====
#pragma once

#ifdef ESP_PLATFORM
#include "port_config.hpp"
#endif

#include "ethernet_defs.hpp"
#ifndef V2GTP_BUFFER_SIZE
#define V2GTP_BUFFER_SIZE 1536
#endif

static_assert(ETH_FRAME_LEN <= V2GTP_BUFFER_SIZE,
              "ETH_FRAME_LEN must not exceed V2GTP_BUFFER_SIZE");
#include <slac/transport.hpp>

#ifdef ARDUINO
#include <HardwareSerial.h>
#endif

struct qca7000_uart_config {
    HardwareSerial* serial;
    uint32_t baud;
    const uint8_t* mac_addr{nullptr};
};

void uartQca7000Teardown();

namespace slac {
namespace port {

class Qca7000UartLink : public transport::Link {
public:
    explicit Qca7000UartLink(const qca7000_uart_config& cfg);

    bool open() override;
    bool write(const uint8_t* b, size_t l, uint32_t timeout_ms) override;
    transport::LinkError read(uint8_t* b, size_t l, size_t* out, uint32_t timeout_ms) override;
    const uint8_t* mac() const override;

    bool init_failed() const {
        return initialization_error;
    }
    bool is_initialized() const {
        return initialized;
    }

    /// Close the UART connection and reset internal state
    void close();

    ~Qca7000UartLink();

private:
    bool initialized{false};
    bool initialization_error{false};
    qca7000_uart_config cfg;
    uint8_t mac_addr[ETH_ALEN]{};
};

} // namespace port
} // namespace slac


// ===== port\logging_compat.hpp =====
#ifndef SLAC_LOGGING_COMPAT_HPP
#define SLAC_LOGGING_COMPAT_HPP

#ifdef ESP_PLATFORM
#include <esp_log.h>
#else
#ifndef ESP_LOGE
#define ESP_LOGE(tag, fmt, ...)
#endif
#ifndef ESP_LOGI
#define ESP_LOGI(tag, fmt, ...)
#endif
#ifndef ESP_LOGW
#define ESP_LOGW(tag, fmt, ...)
#endif
#endif

#endif // SLAC_LOGGING_COMPAT_HPP


// ===== port\port_common.hpp =====
#ifndef SLAC_GENERIC_PORT_CONFIG_HPP
#define SLAC_GENERIC_PORT_CONFIG_HPP

#include <stdint.h>

#ifdef ARDUINO
#include <Arduino.h>
#endif

#ifndef slac_millis
#if defined(ARDUINO) && !defined(ESP_PLATFORM)
static inline uint32_t slac_millis() { return millis(); }
#endif
#endif

#ifndef slac_delay
#if defined(ARDUINO) && !defined(ESP_PLATFORM)
static inline void slac_delay(uint32_t ms) { delay(ms); }
#endif
#endif

#ifndef slac_noInterrupts
#if defined(ARDUINO) && !defined(ESP_PLATFORM)
static inline void slac_noInterrupts() { noInterrupts(); }
#endif
#endif

#ifndef slac_interrupts
#if defined(ARDUINO) && !defined(ESP_PLATFORM)
static inline void slac_interrupts() { interrupts(); }
#endif
#endif

#endif // SLAC_GENERIC_PORT_CONFIG_HPP


// ===== src\channel.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2024 Joulepoint Private Limited (Author Chinmoy Bhuyan)
#include <slac/channel.hpp>
#ifdef ESP_PLATFORM
#include "port/port_common.hpp"
#endif

#include <algorithm>
#include <cassert>
#include <cstring>

#include <slac/transport.hpp>

namespace slac {

Channel::Channel(transport::Link* l) : link(l) {
}

bool Channel::open() {
    did_timeout = false;
    if (!link)
        return false;

    if (!link->open())
        return false;

    memcpy(orig_if_mac, link->mac(), sizeof(orig_if_mac));
    return true;
}

Channel::~Channel() = default;

transport::LinkError Channel::read(slac::messages::HomeplugMessage& msg, int timeout) {
    did_timeout = false;
    if (!link)
        return transport::LinkError::Transport;

    size_t out_len = 0;
    auto res = link->read(reinterpret_cast<uint8_t*>(msg.get_raw_message_ptr()),
                          sizeof(messages::homeplug_message), &out_len, timeout);
    did_timeout = res == transport::LinkError::Timeout;
    if (res != transport::LinkError::Ok) {
        return res;
    }
    if (out_len == 0 && timeout > 0) {
        return transport::LinkError::Timeout;
    }

    if (out_len < defs::MME_MIN_LENGTH || out_len > sizeof(messages::homeplug_message)) {
        return transport::LinkError::Transport;
    }

    msg.set_raw_msg_len(static_cast<int>(out_len));
    return transport::LinkError::Ok;
}

bool Channel::poll(slac::messages::HomeplugMessage& msg) {
    did_timeout = false;
    if (!link) {
        error = "No transport link";
        return false;
    }

    size_t out_len = 0;
    const int timeout = 0;
    auto res = link->read(reinterpret_cast<uint8_t*>(msg.get_raw_message_ptr()),
                          sizeof(messages::homeplug_message), &out_len, timeout);
    did_timeout = res == transport::LinkError::Timeout;
    if (res != transport::LinkError::Ok) {
        switch (res) {
        case transport::LinkError::Timeout:
            error = "Timeout";
            break;
        case transport::LinkError::Transport:
            error = "Transport error";
            break;
        default:
            error = "Link error";
            break;
        }
        return false;
    }

    if (out_len < defs::MME_MIN_LENGTH || out_len > sizeof(messages::homeplug_message)) {
        error = "Invalid frame length";
        return false;
    }

    msg.set_raw_msg_len(static_cast<int>(out_len));
    return true;
}

bool Channel::write(slac::messages::HomeplugMessage& msg, int timeout) {
    did_timeout = false;

    if (!link) {
        error = "No transport link";
        return false;
    }

    if (!msg.is_valid()) {
        error = "Invalid HomeplugMessage";
        return false;
    }

    auto raw_msg_ether_shost = msg.get_src_mac();
    if (!msg.keep_source_mac()) {
        memcpy(raw_msg_ether_shost, orig_if_mac, sizeof(orig_if_mac));
    }

    if (!link->write(reinterpret_cast<const uint8_t*>(msg.get_raw_message_ptr()),
                     msg.get_raw_msg_len(), timeout)) {
        error = "Write failed";
        return false;
    }

    return true;
}

const uint8_t* Channel::get_mac_addr() {
    return orig_if_mac;
}

} // namespace slac


// ===== src\slac.cpp =====
// SPDX-License-Identifier: Apache-2.0
// Copyright 2024 Joulepoint Private Limited (Author Chinmoy Bhuyan)
#include <slac/slac.hpp>
#ifdef ESP_PLATFORM
#include "port/port_common.hpp"
#endif

#include <algorithm>
#include <cassert>
#include <cstring>
#include <type_traits>

#include <arpa/inet.h>
#include <slac/endian.hpp>

#include <hash_library/sha256.h>

namespace slac {
namespace utils {

// note on byte order:
//   - sha256 takes the most significant byte first from the lowest
//     memory address
//   - for the generation of the aes-128, or NMK-HS, the first octet of
//     the sha256 output is taken as the zero octet for the NMK-HS
//   - for the generation of NID, the NMK is fed into sha256, so having
//     a const char* as input should be the proper byte ordering already
void generate_nmk_hs(uint8_t nmk_hs[slac::defs::NMK_LEN], const char* plain_password, int password_len) {
    SHA256 sha256;

    // do pbkdf1 (use sha256 as hashing function, iterate 1000 times,
    // use salt)
    sha256.add(plain_password, password_len);
    sha256.add(slac::defs::NMK_HASH, sizeof(slac::defs::NMK_HASH));

    uint8_t hash[SHA256::HashBytes];
    sha256.getHash(hash);
    for (int i = 0; i < 1000 - 1; ++i) {
        sha256(hash, sizeof(hash));
        sha256.getHash(hash);
    }

    memcpy(nmk_hs, hash, slac::defs::NMK_LEN);
}

void generate_nid_from_nmk(uint8_t nid[slac::defs::NID_LEN], const uint8_t nmk[slac::defs::NMK_LEN]) {
    SHA256 sha256;

    // msb of least significant octet of NMK should be the leftmost bit
    // of the input, which corresponds to the usual const char* order

    // do pbkdf1 (use sha256 as hashing function, iterate 5 times, no
    // salt)
    uint8_t hash[SHA256::HashBytes];
    sha256(nmk, slac::defs::NMK_LEN);
    sha256.getHash(hash);
    for (int i = 0; i < 5 - 1; ++i) {
        sha256(hash, sizeof(hash));
        sha256.getHash(hash);
    }

    // use leftmost 52 bits of the hash output
    // left most bit should be bit 7 of the nid
    memcpy(nid, hash, slac::defs::NID_LEN - 1); // (bits 52 - 5)
    nid[slac::defs::NID_LEN - 1] =
        (slac::defs::NID_SECURITY_LEVEL_SIMPLE_CONNECT << slac::defs::NID_SECURITY_LEVEL_OFFSET) |
        ((static_cast<uint8_t>(hash[6])) >> slac::defs::NID_MOST_SIGNIFANT_BYTE_SHIFT);
}

} // namespace utils

namespace messages {

static constexpr auto effective_payload_length(const defs::MMV mmv) {
    if (mmv == defs::MMV::AV_1_0) {
        return sizeof(homeplug_message::payload);
    } else {
        return sizeof(homeplug_message::payload) - sizeof(homeplug_fragmentation_part);
    }
}

bool HomeplugMessage::setup_payload(void const* payload, int len, uint16_t mmtype, const defs::MMV mmv) {
    const auto max_len = effective_payload_length(mmv);
    if (len > max_len) {
        // mark the message invalid and signal the failure
        assert(("Homeplug Payload length too long", len <= max_len));
        raw_msg_len = -1;
        return false;
    }
    raw_msg.homeplug_header.mmv = static_cast<std::underlying_type_t<defs::MMV>>(mmv);
    raw_msg.homeplug_header.mmtype = slac::htole16(mmtype);

    uint8_t* dst = raw_msg.payload;

    if (mmv != defs::MMV::AV_1_0) {
        homeplug_fragmentation_part fragmentation_part{};
        fragmentation_part.fmni = 0; // not implemented
        fragmentation_part.fmsn = 0; // not implemented
        memcpy(dst, &fragmentation_part, sizeof(fragmentation_part));
        dst += sizeof(fragmentation_part); // adjust effective payload start
    }

    // copy payload into place
    memcpy(dst, payload, len);

    // get pointer to the end of buffer
    uint8_t* dst_end = dst + len;

    // calculate raw message length
    raw_msg_len = dst_end - reinterpret_cast<uint8_t*>(&raw_msg);

    // do padding
    auto padding_len = defs::MME_MIN_LENGTH - raw_msg_len;
    if (padding_len > 0) {
        memset(dst_end, 0x00, padding_len);
        raw_msg_len = defs::MME_MIN_LENGTH;
    }

    return true;
}

void HomeplugMessage::setup_ethernet_header(const uint8_t dst_mac_addr[ETH_ALEN],
                                            const uint8_t src_mac_addr[ETH_ALEN]) {

    // ethernet frame byte order is big endian
    raw_msg.ethernet_header.ether_type = htons(defs::ETH_P_HOMEPLUG_GREENPHY);
    if (dst_mac_addr) {
        memcpy(raw_msg.ethernet_header.ether_dhost, dst_mac_addr, ETH_ALEN);
    }

    if (src_mac_addr) {
        memcpy(raw_msg.ethernet_header.ether_shost, src_mac_addr, ETH_ALEN);
        keep_src_mac = true;
    } else {
        keep_src_mac = false;
    }
}

uint16_t HomeplugMessage::get_mmtype() const {
    return slac::le16toh(raw_msg.homeplug_header.mmtype);
}

uint8_t* HomeplugMessage::get_src_mac() {
    return raw_msg.ethernet_header.ether_shost;
}

void HomeplugMessage::set_raw_msg_len(int len) {
    raw_msg_len = len;
}

bool HomeplugMessage::is_valid() const {
    return raw_msg_len >= static_cast<int>(defs::MME_MIN_LENGTH);
}

} // namespace messages
} // namespace slac


// ===== tests\Arduino.h =====
#pragma once
#include "arduino_stubs.hpp"


// ===== tests\arduino_stubs.hpp =====
#pragma once
#include <cstdint>
#include <cstddef>

#define HIGH 1
#define LOW 0
#define OUTPUT 1

struct SPISettings {
    SPISettings(uint32_t, uint8_t, uint8_t) {}
};

class SPIClass {
public:
    void begin() {}
    void beginTransaction(const SPISettings&) {}
    void endTransaction() {}
    uint8_t transfer(uint8_t) { return 0; }
    uint16_t transfer16(uint16_t) { return 0; }
    void writeBytes(const uint8_t*, size_t) {}
};

extern SPIClass SPI;
inline SPIClass SPI;

inline void pinMode(int, int) {}
inline void digitalWrite(int, int) {}
inline uint32_t millis() { return 0; }
inline void delay(unsigned int) {}
inline void noInterrupts() {}
inline void interrupts() {}


// ===== tests\qca7000_hal_mock.cpp =====
#include "arduino_stubs.hpp"
#include "port/esp32s3/qca7000.hpp"
#include <cstring>

SPIClass* spi_used = nullptr;
int spi_cs = -1;
int spi_rst = -1;

uint8_t myethtransmitbuffer[V2GTP_BUFFER_SIZE];
size_t myethtransmitlen = 0;
uint8_t myethreceivebuffer[V2GTP_BUFFER_SIZE];
size_t myethreceivelen = 0;
const char* PLC_TAG = "mock";

bool qca7000setup(SPIClass* spi, int cs, int rst) {
    spi_used = spi; spi_cs = cs; spi_rst = rst; return true;
}

void qca7000teardown() { spi_used = nullptr; }

bool qca7000ResetAndCheck() { return true; }
uint16_t qca7000ReadInternalReg(uint16_t) { return 0; }
bool qca7000ReadSignature(uint16_t* sig, uint16_t* ver) { if(sig) *sig = 0xAA55; if(ver) *ver=1; return true; }
size_t spiQCA7000checkForReceivedData(uint8_t* dst, size_t len) {
    size_t c = myethreceivelen > len ? len : myethreceivelen;
    memcpy(dst, myethreceivebuffer, c);
    myethreceivelen = 0;
    return c;
}
bool spiQCA7000SendEthFrame(const uint8_t* f, size_t l) {
    if(l>sizeof(myethtransmitbuffer)) l = sizeof(myethtransmitbuffer);
    memcpy(myethtransmitbuffer, f, l); myethtransmitlen = l; return true;
}
bool qca7000startSlac() { return true; }
uint8_t qca7000getSlacResult() { return 0; }
void qca7000Process() {}
void qca7000SetErrorCallback(qca7000_error_cb_t, void*, bool*) {}


// ===== tests\SPI.h =====
#pragma once
#include "arduino_stubs.hpp"


// ===== tests\test_channel.cpp =====
#include <gtest/gtest.h>
#include <slac/channel.hpp>
#include <slac/slac.hpp>
#include <vector>
#include <cstring>

class MockLink : public slac::transport::Link {
public:
    bool open() override { return true; }
    bool write(const uint8_t* b, size_t l, uint32_t) override {
        tx.assign(b, b + l);
        rx = tx;
        return true;
    }
    slac::transport::LinkError read(uint8_t* b, size_t l, size_t* out, uint32_t) override {
        if (rx.empty()) {
            if (out)
                *out = 0;
            return slac::transport::LinkError::Timeout;
        }
        size_t copy = std::min(l, rx.size());
        memcpy(b, rx.data(), copy);
        rx.clear();
        if (out)
            *out = copy;
        return slac::transport::LinkError::Ok;
    }
    const uint8_t* mac() const override { return MAC; }
    static inline uint8_t MAC[6] = {0x02,0,0,0,0,1};
    std::vector<uint8_t> tx;
    std::vector<uint8_t> rx;
};

TEST(Channel, RoundTrip) {
    MockLink link;
    slac::Channel channel(&link);
    ASSERT_TRUE(channel.open());

    slac::messages::HomeplugMessage msg;
    slac::messages::cm_slac_parm_req req{};
    req.application_type = 0;
    req.security_type = 0;
    memset(req.run_id, 0, sizeof(req.run_id));

    ASSERT_TRUE(msg.setup_payload(&req, sizeof(req),
                                  slac::defs::MMTYPE_CM_SLAC_PARAM | slac::defs::MMTYPE_MODE_REQ,
                                  slac::defs::MMV::AV_1_0));
    uint8_t dst[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
    msg.setup_ethernet_header(dst);

    ASSERT_TRUE(channel.write(msg, 100));

    slac::messages::HomeplugMessage in;
    auto err = channel.read(in, 100);
    ASSERT_EQ(err, slac::transport::LinkError::Ok);
    EXPECT_EQ(in.get_mmtype(), msg.get_mmtype());
    EXPECT_EQ(in.get_raw_msg_len(), msg.get_raw_msg_len());
    EXPECT_EQ(0, memcmp(in.get_raw_message_ptr(), msg.get_raw_message_ptr(), msg.get_raw_msg_len()));
}

TEST(Channel, WriteAfterSetupFailure) {
    MockLink link;
    slac::Channel channel(&link);
    ASSERT_TRUE(channel.open());

    slac::messages::HomeplugMessage msg;
    slac::messages::cm_slac_parm_req req{};
    req.application_type = 0;
    req.security_type = 0;
    memset(req.run_id, 0, sizeof(req.run_id));

    ASSERT_TRUE(msg.setup_payload(&req, sizeof(req),
                                  slac::defs::MMTYPE_CM_SLAC_PARAM | slac::defs::MMTYPE_MODE_REQ,
                                  slac::defs::MMV::AV_1_0));
    uint8_t dst[ETH_ALEN] = {0xff,0xff,0xff,0xff,0xff,0xff};
    msg.setup_ethernet_header(dst);

    ASSERT_TRUE(channel.write(msg, 100));

    const size_t big_len = sizeof(slac::messages::homeplug_message::payload) + 1;
    std::vector<uint8_t> big(big_len, 0);
    EXPECT_FALSE(msg.setup_payload(big.data(), big.size(),
                                   slac::defs::MMTYPE_CM_SLAC_PARAM | slac::defs::MMTYPE_MODE_REQ,
                                   slac::defs::MMV::AV_1_0));
    EXPECT_FALSE(msg.is_valid());
    msg.setup_ethernet_header(dst);
    EXPECT_FALSE(channel.write(msg, 100));
}


// ===== tests\test_endian.cpp =====
#include <gtest/gtest.h>
#include <slac/endian.hpp>

TEST(Endian, Swap) {
    EXPECT_EQ(slac::bswap16(0x1234u), 0x3412u);
    EXPECT_EQ(slac::bswap32(0x11223344u), 0x44332211u);
    EXPECT_EQ(slac::bswap64(0x1122334455667788ull), 0x8877665544332211ull);
}

TEST(Endian, HostLE) {
    uint16_t v16 = 0xA1B2u;
    uint32_t v32 = 0xA1B2C3D4u;
    uint64_t v64 = 0x1122334455667788ull;
    EXPECT_EQ(slac::htole16(v16), v16);
    EXPECT_EQ(slac::le16toh(v16), v16);
    EXPECT_EQ(slac::htole32(v32), v32);
    EXPECT_EQ(slac::le32toh(v32), v32);
    EXPECT_EQ(slac::htole64(v64), v64);
    EXPECT_EQ(slac::le64toh(v64), v64);
}


// ===== tests\test_fsm.cpp =====
#include <gtest/gtest.h>
#include <fsm/fsm.hpp>
#include <fsm/buffer.hpp>

namespace {

enum class Ev { Add, Unknown };

struct Compound;

using Buffer = fsm::buffer::SwapBuffer<64, 64, 1>;
using FSMType = fsm::FSM<Ev, int, Buffer>;
using Allocator = FSMType::StateAllocatorType;
using SimpleBase = FSMType::SimpleStateType;
using CompoundBase = FSMType::CompoundStateType;

struct Simple : public SimpleBase {
    fsm::states::HandleEventResult handle_event(Allocator& alloc, Ev ev) override {
        if (ev == Ev::Add) {
            alloc.create_compound<Compound>();
            return alloc.create_simple<Simple>();
        }
        return Allocator::PASS_ON;
    }
};

struct Compound : public CompoundBase {
    fsm::states::HandleEventResult handle_event(Allocator&, Ev) override { return Allocator::PASS_ON; }
};

} // namespace

TEST(StateAllocator, Overflow) {
    Buffer buf{};
    fsm::_impl::StateAllocator<Buffer> alloc(buf);
    alloc.make_ready_for_nesting_level(Buffer::MAX_NESTING_LEVEL);
    bool ok = alloc.create_compound<Compound>();
    EXPECT_FALSE(ok);
    EXPECT_EQ(alloc.get_internal_state(), fsm::_impl::StateAllocator<Buffer>::InternalState::FAILED_COMPOUND_OVERFLOW);
}

TEST(FSM, UnhandledPassThrough) {
    Buffer buf{};
    FSMType fsm(buf);
    fsm.reset<Simple>();
    EXPECT_EQ(fsm.handle_event(Ev::Add), fsm::HandleEventResult::SUCCESS);
    EXPECT_EQ(fsm.handle_event(Ev::Unknown), fsm::HandleEventResult::UNHANDLED);
}


// ===== tests\test_fsm_buffer.cpp =====
#include <gtest/gtest.h>
#include <fsm/fsm.hpp>
#include <fsm/buffer.hpp>

namespace {

enum class E { Go };

using Buffer = fsm::buffer::SwapBuffer<64,64,1>;
using FSMType = fsm::FSM<E, int, Buffer>;
using Alloc = FSMType::StateAllocatorType;
using SimpleBase = FSMType::SimpleStateType;

struct Next : public SimpleBase {
    fsm::states::HandleEventResult handle_event(Alloc&, E) override {
        return Alloc::PASS_ON;
    }
};

struct Start : public SimpleBase {
    fsm::states::HandleEventResult handle_event(Alloc& alloc, E) override {
        return alloc.create_simple<Next>();
    }
};

}

TEST(FSMBuffer, SimpleTransition) {
    Buffer buf{};
    FSMType fsm(buf);
    fsm.reset<Start>();
    EXPECT_EQ(fsm.handle_event(E::Go), fsm::HandleEventResult::SUCCESS);
}


// ===== tests\test_payload.cpp =====
#include <gtest/gtest.h>
#include <slac/slac.hpp>
#include <cstring>

using namespace slac;

TEST(Payload, BuildAV10) {
    messages::HomeplugMessage msg;
    uint8_t payload[10];
    for (int i = 0; i < 10; ++i)
        payload[i] = i;

    ASSERT_TRUE(msg.setup_payload(payload, sizeof(payload), 0x1234, defs::MMV::AV_1_0));
    EXPECT_TRUE(msg.is_valid());
    EXPECT_EQ(msg.get_mmtype(), 0x1234);
    EXPECT_EQ(msg.get_raw_msg_len(), defs::MME_MIN_LENGTH);

    auto raw = msg.get_raw_message_ptr();
    EXPECT_EQ(raw->homeplug_header.mmv, static_cast<uint8_t>(defs::MMV::AV_1_0));
    EXPECT_EQ(memcmp(raw->payload, payload, sizeof(payload)), 0);
}

TEST(Payload, BuildAV20Frag) {
    messages::HomeplugMessage msg;
    uint8_t payload[8];
    for (int i = 0; i < 8; ++i)
        payload[i] = i + 1;

    ASSERT_TRUE(msg.setup_payload(payload, sizeof(payload), 0x4321, defs::MMV::AV_2_0));
    auto raw = msg.get_raw_message_ptr();
    EXPECT_EQ(raw->homeplug_header.mmv, static_cast<uint8_t>(defs::MMV::AV_2_0));
    const messages::homeplug_fragmentation_part* frag =
        reinterpret_cast<const messages::homeplug_fragmentation_part*>(raw->payload);
    EXPECT_EQ(frag->fmni, 0);
    EXPECT_EQ(frag->fmsn, 0);
    EXPECT_EQ(memcmp(raw->payload + sizeof(*frag), payload, sizeof(payload)), 0);
}

TEST(Payload, TooLong) {
    messages::HomeplugMessage msg;
    const size_t big_len = sizeof(messages::homeplug_message::payload) + 1;
    std::vector<uint8_t> big(big_len, 0);
    EXPECT_FALSE(msg.setup_payload(big.data(), big.size(), 0x1000, defs::MMV::AV_1_0));
    EXPECT_FALSE(msg.is_valid());
}


// ===== tests\test_qca7000_link.cpp =====
#include <gtest/gtest.h>
#define ARDUINO
#include "arduino_stubs.hpp"
#include "port/esp32s3/qca7000_link.hpp"
#include "port/esp32s3/qca7000.hpp"

using slac::port::Qca7000Link;

TEST(Qca7000LinkIntegration, BasicReadWrite) {
    qca7000_config cfg{};
    cfg.spi = &SPI;
    cfg.cs_pin = 5;
    cfg.rst_pin = 6;
    Qca7000Link link(cfg);
    ASSERT_TRUE(link.open());

    uint8_t frame[6] = {1,2,3,4,5,6};
    EXPECT_TRUE(link.write(frame, sizeof(frame), 0));

    memcpy(myethreceivebuffer, frame, sizeof(frame));
    myethreceivelen = sizeof(frame);

    uint8_t buf[10];
    size_t out = 0;
    auto err = link.read(buf, sizeof(buf), &out, 10);
    EXPECT_EQ(err, slac::transport::LinkError::Ok);
    EXPECT_EQ(out, sizeof(frame));
    EXPECT_EQ(0, memcmp(buf, frame, sizeof(frame)));

    link.close();
}


// ===== tests\test_sha256.cpp =====
#include <gtest/gtest.h>
#include <hash_library/sha256.h>

TEST(SHA256, KnownVectors) {
    SHA256 sha;
    EXPECT_EQ(sha("abc"),
              std::string("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"));
    EXPECT_EQ(sha(""),
              std::string("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"));
}


